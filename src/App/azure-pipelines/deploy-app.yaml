
variables:
  # Variables that are dynamically set in the pipeline
  ALTINN_HOST: ''
  RELEASE_NAME: ''
  RG_NAME: ''
  AI_INSTR_KEY: ''
  SUBSCRIPTION_KEY: ''

  # Variables that should be set as secret variables in the pipeline
  # APIM_RESOURCE_ID_PROD: ''
  # AZURE_SUBSCRIPTION_ID_PLATFORM_STAGING: ''
  # AZURE_SUBSCRIPTION_ID_PLATFORM_TEST: ''

  # Variables to be passed when triggering the pipeline
  # ALTINN_STUDIO_HOSTNAME: ''
  # APP_COMMIT_ID: ''
  # APP_DEPLOY_TOKEN: ''
  # APP_ENVIRONMENT: ''
  # APP_OWNER: ''
  # APP_REPO: ''
  # GITEA_ENVIRONMENT: ''
  # HOSTNAME: ''
  # TAGNAME: ''
  # TRACEPARENT: '' # Optional W3C traceparent for correlation
  # TRACESTATE: '' # Optional W3C tracestate for correlation
  # PUSH_SYNCROOT_GITOPS_IMAGE: 'false' # Set to 'true' to enable pushing sync-root artifact
  # PUSH_APPS_OCI_IMAGE: 'true' # Set to 'false' to skip pushing app OCI image

  # Variables for generating yaml files. Paths are relative to the root of the apps repository
  FLUX_ARTIFACT_DIR: 'flux-artifact'
  HELMRELEASE_FILE: 'helmrelease.yaml'
  OVERRIDES_FILE: 'overrides.yaml'
  VALUES_FILE: 'deployment/values.yaml'
  NORMALIZED_VALUES: 'values.normalized.yaml'
  MERGED_VALUES: 'values.merged.yaml'
  MASKINPORTEN_CR_FILE: 'maskinportenclient.yaml'

  AI_SERVICE_CONNECTION_ID_TEST: 'c3cabb67-2cf6-4114-acd3-e1f0e32eea82'
  AI_SERVICE_CONNECTION_ID_PROD: '4c145755-0ab0-4c62-b182-4d2fbb9563ed'

  GITOPS_ORGANIZATION: 'als'
  GITOPS_REPO_SUFFIX: '-gitops'
  GITOPS_REPO_CLONE_DIR: 'gitops'


trigger: none
pr: none

steps:
  - checkout: none

  - task: Bash@3
    displayName: 'Validate required variables'
    inputs:
      targetType: inline
      script: |
        ERRORS=()

        # Always required variables
        [ -z "$APP_OWNER" ] && ERRORS+=("APP_OWNER is required")
        [ -z "$APP_ENVIRONMENT" ] && ERRORS+=("APP_ENVIRONMENT is required")
        [ -z "$ALTINN_STUDIO_HOSTNAME" ] && ERRORS+=("ALTINN_STUDIO_HOSTNAME is required")

        # Variables required when pushing app OCI image (default behavior)
        if [ "$PUSH_APPS_OCI_IMAGE" != "false" ]; then
          [ -z "$APP_REPO" ] && ERRORS+=("APP_REPO is required when PUSH_APPS_OCI_IMAGE is not 'false'")
          [ -z "$GITEA_ENVIRONMENT" ] && ERRORS+=("GITEA_ENVIRONMENT is required when PUSH_APPS_OCI_IMAGE is not 'false'")
          [ -z "$APP_COMMIT_ID" ] && ERRORS+=("APP_COMMIT_ID is required when PUSH_APPS_OCI_IMAGE is not 'false'")
          [ -z "$TAGNAME" ] && ERRORS+=("TAGNAME is required when PUSH_APPS_OCI_IMAGE is not 'false'")
        fi

        # Variables required when pushing sync-root GitOps image
        if [ "$PUSH_SYNCROOT_GITOPS_IMAGE" == "true" ]; then
          [ -z "$GITEA_ENVIRONMENT" ] && ERRORS+=("GITEA_ENVIRONMENT is required when PUSH_SYNCROOT_GITOPS_IMAGE is 'true'")
        fi

        # Print all errors and exit if any
        if [ ${#ERRORS[@]} -gt 0 ]; then
          echo "##[error]Variable validation failed:"
          for error in "${ERRORS[@]}"; do
            echo "##[error]  - $error"
          done
          exit 1
        fi

        echo "All required variables are set"
      failOnStderr: true

  - task: Bash@3
    displayName: 'Set STUDIO_ENVIRONMENT based on ALTINN_STUDIO_HOSTNAME'
    inputs:
      targetType: inline
      script: |
        case "$ALTINN_STUDIO_HOSTNAME" in
          "dev.altinn.studio")
            STUDIO_ENV="dev"
            ;;
          "staging.altinn.studio")
            STUDIO_ENV="staging"
            ;;
          "altinn.studio")
            STUDIO_ENV="prod"
            ;;
          *)
            echo "Unknown ALTINN_STUDIO_HOSTNAME: $ALTINN_STUDIO_HOSTNAME"
            exit 1
            ;;
        esac
        echo "##vso[task.setvariable variable=STUDIO_ENVIRONMENT;]$STUDIO_ENV"
      failOnStderr: true

  - task: Bash@3
    name: RELEASE_NAME
    displayName: 'Create lowercase release name '
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      targetType: inline
      script: |
        APP_OWNER_LOWERCASE=$(echo $APP_OWNER | tr '[:upper:]' '[:lower:]')

        APP_REPO_LOWERCASE=$(echo $APP_REPO | tr '[:upper:]' '[:lower:]')

        RELEASE_NAME_LOWERCASE="$APP_OWNER_LOWERCASE-$APP_REPO_LOWERCASE"

        echo $RELEASE_NAME_LOWERCASE

        echo "##vso[task.setvariable variable=RELEASE_NAME;]$RELEASE_NAME_LOWERCASE"
      failOnStderr: true

  - task: CmdLine@2
    displayName: Pull Repo
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      script: |
        # Should use oauth token when authenticating to private repo

        git clone --recurse-submodules https://$(APP_DEPLOY_TOKEN)@$GITEA_ENVIRONMENT/$APP_OWNER/$APP_REPO $APP_COMMIT_ID
        cd $APP_COMMIT_ID

        ## Ensure we use correct commit
        # Get the latest commit ID of the current git branch
        latestCommit=$(git rev-parse HEAD)

        # Compare the commits
        if [ "$targetCommit" == "$APP_COMMIT_ID" ]; then
            echo "Already using latest commit on this branch, moving on."
        else
            echo "Target commit ID is not latest commit on this branch. Fetching target commit"
            git fetch origin $APP_COMMIT_ID
            git reset --hard FETCH_HEAD
        fi

  - task: AzureCLI@2
    displayName: 'Extract app scopes from docker image'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    continueOnError: true
    inputs:
      azureSubscription: 'altinn-studio-apps-deploy'
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        set +e  # Don't exit on errors, this needs testing

        ACR_NAME="${APP_OWNER}altinnregistry01"
        IMAGE_REF="${ACR_NAME}.azurecr.io/${RELEASE_NAME}:${TAGNAME}"

        echo "Extracting Maskinporten scopes from image: ${IMAGE_REF}"

        az acr login --name ${ACR_NAME}

        docker pull ${IMAGE_REF}

        SCOPES_JSON=$(docker inspect ${IMAGE_REF} --format='{{index .Config.Labels "studio.altinn.maskinporten.scopes"}}' 2>/dev/null || echo "[]")

        if [ "$SCOPES_JSON" == "<no value>" ] || [ "$SCOPES_JSON" == "null" ] || [ -z "$SCOPES_JSON" ]; then
          echo "No Maskinporten scopes label found on image, defaulting to empty array"
          SCOPES_JSON="[]"
        fi

        if ! echo "${SCOPES_JSON}" | jq empty 2>/dev/null; then
          echo "##[warning]Invalid JSON in Maskinporten scopes label: ${SCOPES_JSON}"
          echo "##[warning]Defaulting to empty array"
          SCOPES_JSON="[]"
        fi

        echo "##vso[task.setvariable variable=APP_MASKINPORTEN_SCOPES_JSON;]${SCOPES_JSON}"

        echo "Extracted Maskinporten scopes: ${SCOPES_JSON}"

        exit 0  # Always succeed, this needs testing
      failOnStderr: false

  - task: CmdLine@2
    displayName: Pull GitOps directory
    condition: and(succeeded(), eq(variables['PUSH_SYNCROOT_GITOPS_IMAGE'], 'true'))
    inputs:
      script: |
        git clone https://$(APP_DEPLOY_TOKEN)@$GITEA_ENVIRONMENT/$GITOPS_ORGANIZATION/$APP_OWNER$GITOPS_REPO_SUFFIX $GITOPS_REPO_CLONE_DIR

  - task: Bash@3
    displayName: 'Process custom IngressRoute for staf org'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), eq(variables['APP_OWNER'], 'staf'))
    inputs:
      targetType: inline
      script: |
        TEMPLATES_DIR="${APP_COMMIT_ID}/deployment/templates"

        # Check if templates directory exists
        if [ ! -d "$TEMPLATES_DIR" ]; then
          echo "No templates directory found, skipping custom ingress route processing"
          echo "##vso[task.setvariable variable=HAS_CUSTOM_INGRESS_ROUTES;]false"
          exit 0
        fi

        # Count files in templates directory
        FILE_COUNT=$(find "$TEMPLATES_DIR" -maxdepth 1 -type f | wc -l | tr -d ' ')

        if [ "$FILE_COUNT" -eq 0 ]; then
          echo "Templates directory is empty, skipping custom ingress route processing"
          echo "##vso[task.setvariable variable=HAS_CUSTOM_INGRESS_ROUTES;]false"
          exit 0
        elif [ "$FILE_COUNT" -gt 1 ]; then
          echo "##[error]Templates directory contains more than one file ($FILE_COUNT files). Only a single IngressRoute file is supported."
          exit 1
        fi

        # Exactly 1 file - get the file path
        TEMPLATE_FILE=$(find "$TEMPLATES_DIR" -maxdepth 1 -type f)
        echo "Found template file: $TEMPLATE_FILE"

        # Check if it's an IngressRoute
        KIND=$(yq eval '.kind' "$TEMPLATE_FILE")
        if [ "$KIND" != "IngressRoute" ]; then
          echo "##[error]Template file is not an IngressRoute (kind: $KIND). Only IngressRoute templates are supported."
          exit 1
        fi

        echo "Template file is an IngressRoute, mapping to customIngressRoutes format"

        # Filter out linkerd middleware - it will be auto-injected by the helm chart
        LINKERD_MIDDLEWARE="${RELEASE_NAME}-deployment"

        # Extract and map to customIngressRoutes array format, filtering out linkerd middleware
        CUSTOM_ROUTE=$(yq eval '{
          "name": .metadata.name,
          "entryPoints": .spec.entryPoints,
          "routes": [.spec.routes[] | .middlewares = [.middlewares[] | select(.name != "'"${LINKERD_MIDDLEWARE}"'")]]
        }' "$TEMPLATE_FILE")

        # Wrap in array and write to file for merging later
        echo "$CUSTOM_ROUTE" | yq eval '[.]' - > "${APP_COMMIT_ID}/custom-ingress-routes.yaml"
        echo "##vso[task.setvariable variable=HAS_CUSTOM_INGRESS_ROUTES;]true"

        echo "Custom ingress route mapped successfully"

        # Log warning to migrate to values file
        echo ""
        echo "##[warning]Custom IngressRoute in templates folder is deprecated. Please migrate to deployment/values.yaml file."
        echo "##[warning]Add the following to your deployment/values.yaml:"
        echo ""
        echo "customIngressRoutes:"
        cat "${APP_COMMIT_ID}/custom-ingress-routes.yaml"
        echo ""
        echo "##[warning]After migrating, remove the templates folder from your repository."
      failOnStderr: false

  - task: Bash@3
    displayName: 'Fail if unsupported templates directory exists'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), ne(variables['APP_OWNER'], 'staf'))
    inputs:
      targetType: inline
      script: |
        TEMPLATES_DIR="${APP_COMMIT_ID}/deployment/templates"

        # Check if templates directory exists and has files
        if [ -d "$TEMPLATES_DIR" ]; then
          FILE_COUNT=$(find "$TEMPLATES_DIR" -maxdepth 1 -type f | wc -l | tr -d ' ')
          if [ "$FILE_COUNT" -gt 0 ]; then
            echo "##[error]Templates directory contains $FILE_COUNT file(s). Custom templates are not supported. The altinn-studio deployment helm chart will be used directly."
            exit 1
          fi
        fi
      failOnStderr: false

  - task: Bash@3
    displayName: Set environment variables (ALTINN_HOST, RG_NAME) based on APP_ENVIRONMENT
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      targetType: inline
      script: |
        # Define host values
        AT_HOST="altinn.cloud"
        TT_PR_HOST="altinn.no"

        # Set ALTINN_HOST based on environment
        if [ "$APP_ENVIRONMENT" == "tt02" ] || [ "$APP_ENVIRONMENT" == "production" ]; then
            echo "##vso[task.setvariable variable=ALTINN_HOST;]$TT_PR_HOST"
        else
            echo "##vso[task.setvariable variable=ALTINN_HOST;]$AT_HOST"
        fi

        # Set RG_NAME based on environment
        echo "##vso[task.setvariable variable=RG_NAME;]altinnapps-$APP_OWNER-$APP_ENVIRONMENT-rg"

        if [ "$APP_ENVIRONMENT" == "production" ]; then
            echo "##vso[task.setvariable variable=RG_NAME;]altinnapps-$APP_OWNER-prod-rg"
        fi
      failOnStderr: true

  - task: Bash@3
    displayName: Generate PowerShell script for Application Insights
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      targetType: inline
      script: |
        # Create the PowerShell script in the agent's working directory
        cat << 'EOF' > $(Agent.BuildDirectory)/get-app-insights.ps1
        # Determine environment-specific values
        if ("$(APP_ENVIRONMENT)" -eq "production") {
            $subscriptionName = "Altinn-$(APP_OWNER)-Prod"
            $monitorRG = "monitor-$(APP_OWNER)-prod-rg"
            $aiName = "$(APP_OWNER)-prod-ai"
        } else {
            $subscriptionName = "Altinn-$(APP_OWNER)-Test"
            $monitorRG = "monitor-$(APP_OWNER)-$(APP_ENVIRONMENT)-rg"
            $aiName = "$(APP_OWNER)-$(APP_ENVIRONMENT)-ai"
        }

        # Select the correct subscription
        Write-Host "Selecting subscription: $subscriptionName"
        Select-AzSubscription -Subscription $subscriptionName

        $altinnappsRG = "$(RG_NAME)"

        # Check if the monitor resource group exists
        $rgExists = Get-AzResourceGroup -Name $monitorRG -ErrorAction SilentlyContinue

        # Determine which resource group to use
        if ($rgExists) {
            $resourceGroupName = $monitorRG
        } else {
            $resourceGroupName = $altinnappsRG
        }

        Write-Host "Using resource group for Application Insights: $resourceGroupName"

        # Get the Application Insights Instrumentation Key
        $ai_instr_key = (Get-AzApplicationInsights -ResourceGroupName $resourceGroupName -Name $aiName).InstrumentationKey

        # export it as a pipeline variable
        Write-Host "##vso[task.setvariable variable=AI_INSTR_KEY;]$ai_instr_key"
        EOF

        echo "PowerShell script generated successfully"

  - task: AzurePowerShell@4
    displayName: Get application Insights instrumentation key (Production)
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), eq(variables['APP_ENVIRONMENT'], 'production'))
    inputs:
      ConnectedServiceNameARM: $(AI_SERVICE_CONNECTION_ID_PROD)
      ScriptType: FilePath
      ScriptPath: '$(Agent.BuildDirectory)/get-app-insights.ps1'
      azurePowerShellVersion: 'LatestVersion'
      pwsh: true
      TargetAzurePs: LatestVersion

  - task: AzurePowerShell@4
    displayName: Get application Insights instrumentation key (Non-Production)
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), ne(variables['APP_ENVIRONMENT'], 'production'))
    inputs:
      ConnectedServiceNameARM: $(AI_SERVICE_CONNECTION_ID_TEST)
      ScriptType: FilePath
      ScriptPath: '$(Agent.BuildDirectory)/get-app-insights.ps1'
      azurePowerShellVersion: 'LatestVersion'
      pwsh: true
      TargetAzurePs: LatestVersion

  - task: AzurePowerShell@4
    displayName: Ensure API management subscription key - Test
    condition: "and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), ne(variables['APP_ENVIRONMENT'], 'production'), ne(variables['APP_ENVIRONMENT'], 'tt02'))"
    inputs:
      ConnectedServiceNameARM: fa66913f-0df2-411a-89b7-9248e463423d
      ScriptType: InlineScript
      Inline: |
        # THIS SCRIPT WILL ONLY BE RUN IF DEPLOYING TO TEST ENV. SEE CONTROL OPTIONS.

        # Mapping pipeline variables to script variables.
        $appEnvironment = "$(APP_ENVIRONMENT)"
        $appOwner = "$(APP_OWNER)"
        $appName = "$(APP_REPO)"
        $azureSubscriptionId = "$(AZURE_SUBSCRIPTION_ID_PLATFORM_TEST)"

        # PLEASE DON'T USE PIPELINE VARIABLES PAST THIS LINE.

        Write-Host "`nPowerShell script output START`n"

        $apimSubscriptionId = "$appOwner-$appName"

        $apimResourceGroup = "altinnplatform-$appEnvironment-rg"
        $apimInstance = "altinn-$appEnvironment-api"

        if ((Get-AzContext).Subscription.Id -ne $azureSubscriptionId) {
            Write-Host "Setting active Azure subscription."
            Select-AzSubscription -SubscriptionId $azureSubscriptionId | Out-Null
        }

        $apimContext = New-AzApiManagementContext -ResourceGroupName $apimResourceGroup -ServiceName $apimInstance  -ErrorAction Stop

        $subscription = $null
        try {
            Write-Host "Trying to get the APIM subscription for $apimSubscriptionId in $apimInstance."
            $subscription = Get-AzApiManagementSubscriptionKey -Context $apimContext -SubscriptionId $apimSubscriptionId -ErrorAction Stop
            Write-Host "Found the APIM subscription for $apimSubscriptionId in $apimInstance"
        }
        catch {
            if (!$_.Exception.Message.Contains("ResourceNotFound")) {
                throw
            }
        }

        if (!$subscription) {
            Write-Host "Found no APIM subscription for $apimSubscriptionId in $apimInstance. Creating..."
            $subscription = New-AzApiManagementSubscription -Context $apimContext -Scope "/products/apps-access" -Name $apimSubscriptionId -SubscriptionId $apimSubscriptionId -ErrorAction Stop
        }

        if (!$subscription) {
            Throw "Unable to create APIM subscription for $apimSubscriptionId in $apimInstance."
        }

        $subscriptionKey = $subscription.PrimaryKey

        Write-Host "##vso[task.setvariable variable=SUBSCRIPTION_KEY;]$subscriptionKey"

        Write-Host "`nPowerShell script output END`n"
      FailOnStandardError: true
      CustomTargetAzurePs: 12.1.0
      pwsh: true

  - task: AzurePowerShell@4
    displayName: Ensure API management subscription key - Staging
    condition: "and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), eq(variables['APP_ENVIRONMENT'], 'tt02'))"
    inputs:
      ConnectedServiceNameARM: a00b78e7-d6bd-414a-abec-aaae2be043bc
      ScriptType: InlineScript
      Inline: |
        # THIS SCRIPT WILL ONLY BE RUN IF DEPLOYING TO TEST ENV. SEE CONTROL OPTIONS.


        # Mapping pipeline variables to script variables.
        $appEnvironment = "$(APP_ENVIRONMENT)"
        $appOwner = "$(APP_OWNER)"
        $appName = "$(APP_REPO)"
        $azureSubscriptionId = "$(AZURE_SUBSCRIPTION_ID_PLATFORM_STAGING)"

        # PLEASE DON'T USE PIPELINE VARIABLES PAST THIS LINE.

        Write-Host "`nPowerShell script output START`n"

        $apimSubscriptionId = "$appOwner-$appName"

        $apimResourceGroup = "altinnplatform-$appEnvironment-rg"
        $apimInstance = "altinn-$appEnvironment-api"

        if ((Get-AzContext).Subscription.Id -ne $azureSubscriptionId) {
            Write-Host "Setting active Azure subscription."
            Select-AzSubscription -SubscriptionId $azureSubscriptionId | Out-Null
        }

        $apimContext = New-AzApiManagementContext -ResourceGroupName $apimResourceGroup -ServiceName $apimInstance  -ErrorAction Stop

        $subscription = $null
        try {
            Write-Host "Trying to get the APIM subscription for $apimSubscriptionId in $apimInstance."
            $subscription = Get-AzApiManagementSubscriptionKey -Context $apimContext -SubscriptionId $apimSubscriptionId -ErrorAction Stop
            Write-Host "Found the APIM subscription for $apimSubscriptionId in $apimInstance"
        }
        catch {
            if (!$_.Exception.Message.Contains("ResourceNotFound")) {
                throw
            }
        }

        if (!$subscription) {
            Write-Host "Found no APIM subscription for $apimSubscriptionId in $apimInstance. Creating..."
            $subscription = New-AzApiManagementSubscription -Context $apimContext -Scope "/products/apps-access" -Name $apimSubscriptionId -SubscriptionId $apimSubscriptionId -ErrorAction Stop
        }

        if (!$subscription) {
            Throw "Unable to create APIM subscription for $apimSubscriptionId in $apimInstance."
        }

        $subscriptionKey = $subscription.PrimaryKey

        Write-Host "##vso[task.setvariable variable=SUBSCRIPTION_KEY;]$subscriptionKey"

        Write-Host "`nPowerShell script output END`n"
      FailOnStandardError: true
      CustomTargetAzurePs: 12.1.0
      pwsh: true

  - task: AzurePowerShell@4
    displayName: Ensure API management subscription key - Production
    condition: "and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'), eq(variables['APP_ENVIRONMENT'], 'production'))"
    inputs:
      ConnectedServiceNameARM: 09d70185-733d-4973-8dfa-c4be37a8ac3a
      ScriptType: InlineScript
      Inline: |
        # THIS SCRIPT WILL ONLY BE RUN IF DEPLOYING TO PROD ENV. SEE CONTROL OPTIONS.

        if ("$(APP_ENVIRONMENT)" -eq "production"){

            $apimContext = New-AzApiManagementContext -ResourceId $(APIM_RESOURCE_ID_PROD)

            $subscriptionId = "$(APP_OWNER)-$(APP_REPO)"

            try {
              Write-Host "Try Get subscription key for $subscriptionId"
              $subscription = Get-AzApiManagementSubscriptionKey -Context $apimContext -SubscriptionId $subscriptionId
            }
            catch {
              if (!$_.Exception.Message.Contains("ResourceNotFound")) {
                  throw
              }
            }

            if (!$subscription) {
              Write-Host "Found no subscription with id $subscriptionId. Creating..."
              $subscription = New-AzApiManagementSubscription -Context $apimContext -Scope "/products/apps-access" -Name $subscriptionId -SubscriptionId $subscriptionId
            }

            $subscriptionKey = $subscription.PrimaryKey

            Write-Host "##vso[task.setvariable variable=SUBSCRIPTION_KEY;]$subscriptionKey"
        }
      FailOnStandardError: true
      CustomTargetAzurePs: 12.1.0
      pwsh: true

  - task: Bash@3
    displayName: Create flux artifact directory
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      targetType: inline
      script: |
        mkdir $(FLUX_ARTIFACT_DIR)

  - task: Bash@3
    displayName: 'Generate helmrelease template file without values'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      workingDirectory: '$(FLUX_ARTIFACT_DIR)'
      targetType: inline
      script: |
        # Generate HelmRelease template
        # Name format: {org}-{app}-{studio-env} to allow parsing when HelmRelease is deleted (for uninstall events)
        HELMRELEASE_NAME="${RELEASE_NAME}-${STUDIO_ENVIRONMENT}"
        cat << EOF > "${HELMRELEASE_FILE}"
        apiVersion: helm.toolkit.fluxcd.io/v2beta1
        kind: HelmRelease
        metadata:
          name: ${HELMRELEASE_NAME}
          namespace: default
          labels:
            altinn.studio/managed-by: altinn-studio
            altinn.studio/source-environment: ${STUDIO_ENVIRONMENT}
            altinn.studio/build-id: "${BUILD_BUILDID}"
            altinn.studio/org: ${APP_OWNER}
            altinn.studio/app: ${APP_REPO}
        spec:
          releaseName: ${RELEASE_NAME}
          targetNamespace: default
          interval: 5m
          install:
            remediation:
              retries: 1
          upgrade:
            remediation:
              retries: 1
          chart:
            spec:
              version: 3.9.0
              chart: deployment
              sourceRef:
                kind: HelmRepository
                name: altinn-charts
                namespace: default
          values: {}
        EOF

        if [ -n "$TRACEPARENT" ]; then
          yq eval '.metadata.annotations."altinn.studio/traceparent" = env(TRACEPARENT)' --inplace "${HELMRELEASE_FILE}"
        fi

        if [ -n "$TRACESTATE" ]; then
          yq eval '.metadata.annotations."altinn.studio/tracestate" = env(TRACESTATE)' --inplace "${HELMRELEASE_FILE}"
        fi


  - task: Bash@3
    displayName: Generate overrides file.
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      workingDirectory: '$(FLUX_ARTIFACT_DIR)'
      targetType: inline
      script: |

        # Determine base URL prefix and environment
        if [ "$APP_ENVIRONMENT" = "production" ]; then
          BASE_URL="https://platform.${ALTINN_HOST}"
          HOST_NAME="${ALTINN_HOST}"
          ENVIRONMENT="Production"
        else
          BASE_URL="https://platform.${APP_ENVIRONMENT}.${ALTINN_HOST}"
          HOST_NAME="${APP_ENVIRONMENT}.${ALTINN_HOST}"
          ENVIRONMENT="Staging"
        fi

        # Start writing to overrides file
        cat << EOF > "$OVERRIDES_FILE"
        image:
          pullSecrets: []
          repository: ${APP_OWNER}altinnregistry01.azurecr.io/${RELEASE_NAME}
          tag: "${TAGNAME}"
          environment:
            - name: ServiceRepositorySettings__BaseResourceFolderContainer
              value: /AltinnService/
            - name: ServiceRepositorySettings__RepositoryLocation
              value: /AltinnService/
            - name: PlatformSettings__ApiStorageEndpoint
              value: ${BASE_URL}/storage/api/v1/
            - name: PlatformSettings__ApiRegisterEndpoint
              value: ${BASE_URL}/register/api/v1/
            - name: PlatformSettings__ApiProfileEndpoint
              value: ${BASE_URL}/profile/api/v1/
            - name: PlatformSettings__ApiAuthenticationEndpoint
              value: ${BASE_URL}/authentication/api/v1/
            - name: PlatformSettings__ApiAuthorizationEndpoint
              value: ${BASE_URL}/authorization/api/v1/
            - name: PlatformSettings__ApiEventsEndpoint
              value: ${BASE_URL}/events/api/v1/
            - name: PlatformSettings__ApiNotificationEndpoint
              value: ${BASE_URL}/notifications/api/v1/
            - name: GeneralSettings__HostName
              value: ${HOST_NAME}
            - name: AppSettings__OpenIdWellKnownEndpoint
              value: ${BASE_URL}/authentication/api/v1/openid/
            - name: PlatformSettings__SubscriptionKey
              value: ${SUBSCRIPTION_KEY}
            - name: PlatformSettings__ApiAccessManagementEndpoint
              value: ${BASE_URL}/accessmanagement/api/v1/
            - name: PlatformSettings__ApiCorrespondenceEndpoint
              value: ${BASE_URL}/correspondence/api/v1/
            - name: AppSettings__AppInsightsRoleName
              value: ${APP_REPO}
            - name: ApplicationInsights__InstrumentationKey
              value: ${AI_INSTR_KEY}
            - name: ASPNETCORE_ENVIRONMENT
              value: ${ENVIRONMENT}
            - name: AppSettings__AppVersion
              value: "${TAGNAME}"
            - name: PdfGeneratorSettings__ServiceEndpointUri
              value: http://pdf-generator.pdf.svc.cluster.local/pdf
            - name: PlatformSettings__ApiPdf2Endpoint
              value: http://pdf-generator.pdf.svc.cluster.local/pdf
            - name: GeneralSettings__ExternalAppBaseUrl
              value: https://{org}.apps.{hostName}/{org}/{app}/
        EOF

        # Add tt02 and production-specific settings
        if [ "$APP_ENVIRONMENT" = "tt02" ] || [ "$APP_ENVIRONMENT" = "production" ]; then
          cat << EOF >> "$OVERRIDES_FILE"
            - name: AppSettings__EFormidlingSender
              value: "991825827"
            - name: EFormidlingClientSettings__BaseUrl
              value: ${BASE_URL}/eformidling/api/
        EOF
        fi

        # Add service and ingressRoute
        cat << EOF >> "$OVERRIDES_FILE"
        service:
          name: ${RELEASE_NAME}
        ingressRoute:
          tls: {}
          name: ${APP_OWNER}-${APP_REPO}-ingress-route
          routes:
            - kind: Rule
              match: Host(\`${APP_OWNER}.apps.${HOST_NAME}\`)&&PathPrefix(\`/${APP_OWNER}/${APP_REPO}/\`)||Host(\`${APP_OWNER}.apps.${HOST_NAME}\`)&&Path(\`/${APP_OWNER}/${APP_REPO}\`)
              services:
                - name: ${RELEASE_NAME}-deployment
                  port: 80
              middlewares:
                - name: hsts-header
        EOF


  - task: Bash@3
    displayName: 'Generate final helmrelease with merged values from values and overrides file'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      workingDirectory: '$(FLUX_ARTIFACT_DIR)'
      targetType: inline
      script: |
        values_file_path="../${APP_COMMIT_ID}/${VALUES_FILE}"
        # For backward compatibility we need to support two formats of values.yaml:
        # 1) Flat structure where all keys are at root level
        # 2) Nested structure where all keys are under "deployment" key
        # We will normalize both formats to a flat structure for merging with overrides.yaml

        if [[ -f "${values_file_path}" ]]; then
          if yq eval 'has("deployment")' "${values_file_path}" | grep -q true; then
            # .deployment exists → hoist its children to root
            yq eval '(.deployment // {}) * (del(.deployment))' "${values_file_path}" > "${NORMALIZED_VALUES}"
          else
            # .deployment does not exist → use file as-is
            cp "${values_file_path}" "${NORMALIZED_VALUES}"
          fi
        else
          # No values.yaml present → start from empty
          echo "{}" > "${NORMALIZED_VALUES}"
        fi

        # --- Merge normalized values + overrides. Overrides have precedence since those values we don't want to be overridden ---
        yq ea '. as $item ireduce ({}; . * $item )' \
          "${NORMALIZED_VALUES}" \
          "${OVERRIDES_FILE}" > "${MERGED_VALUES}"

        # --- Merge custom ingress routes if available (staf org only) ---
        CUSTOM_INGRESS_FILE="../${APP_COMMIT_ID}/custom-ingress-routes.yaml"
        if [[ "${HAS_CUSTOM_INGRESS_ROUTES}" == "true" ]] && [[ -f "${CUSTOM_INGRESS_FILE}" ]]; then
          echo "Merging custom ingress routes into values"
          yq eval ".customIngressRoutes = load(\"${CUSTOM_INGRESS_FILE}\")" --inplace "${MERGED_VALUES}"
        fi

        # --- Inject merged values into helmrelease.yaml ---
        yq eval '.spec.values = load("'"${MERGED_VALUES}"'")' --inplace "${HELMRELEASE_FILE}"

        # --- Cleanup non used files---
        rm -f "${OVERRIDES_FILE}" "${NORMALIZED_VALUES}" "${MERGED_VALUES}"

  - task: Bash@3
    displayName: 'Generate MaskinportenClient CR'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    continueOnError: true
    inputs:
      workingDirectory: '$(FLUX_ARTIFACT_DIR)'
      targetType: inline
      script: |
        set +e  # Don't exit on errors, this needs testing

        SCOPES_ARRAY="${APP_MASKINPORTEN_SCOPES_JSON:-[]}"

        SCOPE_COUNT=$(echo "${SCOPES_ARRAY}" | jq 'length' 2>/dev/null || echo "0")

        if [ "${SCOPE_COUNT}" -eq 0 ]; then
          echo "No Maskinporten scopes configured, skipping MaskinportenClient CR generation"
          exit 0
        fi

        echo "Generating MaskinportenClient CR with ${SCOPE_COUNT} scopes"

        yq eval --null-input '{
          "apiVersion": "resources.altinn.studio/v1alpha1",
          "kind": "MaskinportenClient",
          "metadata": {
            "name": env(RELEASE_NAME),
            "namespace": "default",
            "labels": {
              "altinn.studio/managed-by": "altinn-studio",
              "altinn.studio/source-environment": env(STUDIO_ENVIRONMENT),
              "altinn.studio/build-id": env(BUILD_BUILDID),
              "altinn.studio/org": env(APP_OWNER),
              "altinn.studio/app": env(APP_REPO)
            }
          },
          "spec": {
            "scopes": []
          }
        }' > "${MASKINPORTEN_CR_FILE}"

        yq eval --inplace ".spec.scopes = $(echo "${SCOPES_ARRAY}" | yq eval --input-format json --output-format json '.')" "${MASKINPORTEN_CR_FILE}"

        echo "Generated MaskinportenClient CR:"
        cat "${MASKINPORTEN_CR_FILE}"

        exit 0  # Always succeed, this needs testing
      failOnStderr: false

  - task: AzureCLI@2
    displayName: 'Push OCI artifact to ACR'
    condition: and(succeeded(), ne(variables['PUSH_APPS_OCI_IMAGE'], 'false'))
    inputs:
      azureSubscription: 'altinn-studio-apps-deploy'
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        ACR_NAME="${APP_OWNER}altinnregistry01"

        # install flux cli
        export FLUX_VERSION=2.6.4
        curl -s https://fluxcd.io/install.sh | sudo -E bash

        # Use Flux to push and tag the artifact
        flux push artifact oci://$ACR_NAME.azurecr.io/configs/$APP_REPO:$APP_ENVIRONMENT-$TAGNAME \
          --path="./$FLUX_ARTIFACT_DIR" \
          --source="https://$GITEA_ENVIRONMENT/$APP_OWNER/$APP_REPO/commit/$APP_COMMIT_ID" \
          --revision="$APP_COMMIT_ID" \
          --provider azure

        # Tag as environment
        flux tag artifact oci://$ACR_NAME.azurecr.io/configs/$APP_REPO:$APP_ENVIRONMENT-$TAGNAME  \
          --tag $APP_ENVIRONMENT \
          --provider azure

  - task: AzureCLI@2
    displayName: 'Push sync-root OCI artifact to ACR'
    condition: and(succeeded(), eq(variables['PUSH_SYNCROOT_GITOPS_IMAGE'], 'true'))
    inputs:
      azureSubscription: 'altinn-studio-apps-deploy'
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        ACR_NAME="${APP_OWNER}altinnregistry01"

        # Create temporary directory for sync-root content (only YAML files)
        SYNC_ROOT_DIR="$(pwd)/sync-root-temp"
        mkdir -p "$SYNC_ROOT_DIR"

        # Copy only YAML files while preserving directory structure
        rsync -av --include='*/' --include='*.yaml' --include='*.yml' --exclude='*' "$GITOPS_REPO_CLONE_DIR/" "$SYNC_ROOT_DIR/"

        # Get current commit ID
        COMMIT_ID="$(cd "$GITOPS_REPO_CLONE_DIR" && git rev-parse HEAD)"

        # Ensure flux cli is installed (reuse from previous task or install if needed)
        if ! command -v flux &> /dev/null; then
            export FLUX_VERSION=2.6.4
            curl -s https://fluxcd.io/install.sh | sudo -E bash
        fi

        # Push the sync-root artifact with commit ID as tag
        flux push artifact oci://$ACR_NAME.azurecr.io/configs/sync-root/$STUDIO_ENVIRONMENT:$COMMIT_ID \
          --path="./sync-root-temp" \
          --source="https://$GITEA_ENVIRONMENT/$GITOPS_ORGANIZATION/$APP_OWNER$GITOPS_REPO_SUFFIX/commit/$COMMIT_ID" \
          --revision="$COMMIT_ID" \
          --provider azure

        # Tag the artifact with environment name as well
        flux tag artifact oci://$ACR_NAME.azurecr.io/configs/sync-root/$STUDIO_ENVIRONMENT:$COMMIT_ID \
          --tag "$APP_ENVIRONMENT" \
          --provider azure

        # Cleanup temporary directory
        rm -rf "$SYNC_ROOT_DIR"
