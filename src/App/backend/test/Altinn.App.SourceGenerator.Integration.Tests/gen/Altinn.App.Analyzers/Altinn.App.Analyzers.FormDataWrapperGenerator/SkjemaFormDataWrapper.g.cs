// <auto-generated/>
#nullable enable

[global::System.CodeDom.Compiler.GeneratedCode("Altinn.App.Analyzers", "1.0.0.0")]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public sealed class Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaFormDataWrapper
    : global::Altinn.App.Core.Internal.Data.IFormDataWrapper
{
    private readonly global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema _dataModel;

    public global::System.Type BackingDataType => typeof(global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema);

    public T BackingData<T>()
        where T : class
    {
        return _dataModel as T
            ?? throw new global::System.InvalidCastException(
                $"Attempted to cast data model of type Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema to {typeof(T).FullName}"
            );
    }

    public Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaFormDataWrapper(object dataModel)
    {
        _dataModel =
            dataModel as global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema
            ?? throw new global::System.ArgumentException(
                $"Data model must be of type Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema, (was {dataModel?.GetType().FullName ?? "null"})"
            );
    }

    #region Getters

    /// <inheritdoc />
    public object? Get(global::System.ReadOnlySpan<char> path)
    {
        if (path.IsEmpty)
        {
            return null;
        }

        return GetRecursive(_dataModel, path, 0);
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "skjemanummer" when nextOffset is -1 && literalIndex is -1 => model.Skjemanummer,
            "skjemaversjon" when nextOffset is -1 && literalIndex is -1 => model.Skjemaversjon,
            "skjemainnhold" => GetRecursive(model.Skjemainnhold, path, literalIndex, nextOffset),
            "eierAdresse" when literalIndex is -1 => GetRecursive(model.EierAdresse, path, nextOffset),
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset
    )
    {
        if (literalIndex == -1)
        {
            return model;
        }

        if (model is null || literalIndex < 0 || literalIndex >= model.Count)
        {
            return null;
        }

        return GetRecursive(model[literalIndex], path, offset);
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => model.AltinnRowId,
            "navn" when nextOffset is -1 && literalIndex is -1 => model.Navn,
            "alder" when nextOffset is -1 && literalIndex is -1 => model.Alder,
            "deltar" when nextOffset is -1 && literalIndex is -1 => model.Deltar,
            "adresse" when literalIndex is -1 => GetRecursive(model.Adresse, path, nextOffset),
            "tidligere-adresse" => GetRecursive(model.TidligereAdresse, path, literalIndex, nextOffset),
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => model.AltinnRowId,
            "gate" when nextOffset is -1 && literalIndex is -1 => model.Gate,
            "postnummer" when nextOffset is -1 && literalIndex is -1 => model.Postnummer,
            "poststed" when nextOffset is -1 && literalIndex is -1 => model.Poststed,
            "tags" => GetRecursive(model.Tags, path, literalIndex, nextOffset),
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<string>? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset
    )
    {
        if (literalIndex == -1)
        {
            return model;
        }

        if (model is null || literalIndex < 0 || literalIndex >= model.Count)
        {
            return null;
        }

        return model[literalIndex];
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset
    )
    {
        if (literalIndex == -1)
        {
            return model;
        }

        if (model is null || literalIndex < 0 || literalIndex >= model.Count)
        {
            return null;
        }

        return GetRecursive(model[literalIndex], path, offset);
    }

    #endregion Getters
    #region Setters

    /// <inheritdoc />
    public bool Set(global::System.ReadOnlySpan<char> path, object? value)
    {
        if (path.IsEmpty)
        {
            return false;
        }

        return SetRecursive(_dataModel, path, 0, value);
    }

    private static bool SetRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        object? value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        var segment = ParseSegment(path, offset, out int nextOffset, out int literalIndex);
        return segment switch
        {
            "skjemanummer" when nextOffset is -1 && literalIndex is -1 => TrySetValue<string>(val => model.Skjemanummer = val, value),
            "skjemaversjon" when nextOffset is -1 && literalIndex is -1 => TrySetValue<string>(val => model.Skjemaversjon = val, value),
            "skjemainnhold" => SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_Skjema_Skjemainnhold(model, path, literalIndex, nextOffset, value),
            "eierAdresse" when literalIndex is -1 => SetRecursive_WithObjectCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_Skjema_EierAdresse(model, path, nextOffset, value),
            _ => false,
        };
    }

    private static bool SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_Skjema_Skjemainnhold(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int nextOffset,
        object? value
    )
    {
        if (model.Skjemainnhold is null)
        {
            try
            {
                model.Skjemainnhold = new global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>();
            }
            catch
            {
                return false;
            }
        }
        return SetRecursive(model.Skjemainnhold, path, literalIndex, nextOffset, value);
    }

    private static bool SetRecursive_WithObjectCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_Skjema_EierAdresse(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema model,
        global::System.ReadOnlySpan<char> path,
        int nextOffset,
        object? value
    )
    {
        if (model.EierAdresse is null)
        {
            try
            {
                model.EierAdresse = global::System.Activator.CreateInstance<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>();
            }
            catch
            {
                return false;
            }
        }
        return SetRecursive(model.EierAdresse, path, nextOffset, value);
    }

    private static bool SetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset,
        object? value
    )
    {
        if (model is null || literalIndex < 0)
        {
            return false;
        }

        // Create list elements if index is out of bounds
        while (model.Count <= literalIndex)
        {
            try
            {
                model.Add(global::System.Activator.CreateInstance<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold>());
            }
            catch
            {
                return false;
            }
        }

        return SetRecursive(model[literalIndex], path, offset, value);
    }

    private static bool SetRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        object? value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        var segment = ParseSegment(path, offset, out int nextOffset, out int literalIndex);
        return segment switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => TrySetValue<global::System.Guid>(val => model.AltinnRowId = val, value),
            "navn" when nextOffset is -1 && literalIndex is -1 => TrySetValue<string>(val => model.Navn = val, value),
            "alder" when nextOffset is -1 && literalIndex is -1 => TrySetValue<int?>(val => model.Alder = val, value),
            "deltar" when nextOffset is -1 && literalIndex is -1 => TrySetValue<bool?>(val => model.Deltar = val, value),
            "adresse" when literalIndex is -1 => SetRecursive_WithObjectCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaInnhold_Adresse(model, path, nextOffset, value),
            "tidligere-adresse" => SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaInnhold_TidligereAdresse(model, path, literalIndex, nextOffset, value),
            _ => false,
        };
    }

    private static bool SetRecursive_WithObjectCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaInnhold_Adresse(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold model,
        global::System.ReadOnlySpan<char> path,
        int nextOffset,
        object? value
    )
    {
        if (model.Adresse is null)
        {
            try
            {
                model.Adresse = global::System.Activator.CreateInstance<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>();
            }
            catch
            {
                return false;
            }
        }
        return SetRecursive(model.Adresse, path, nextOffset, value);
    }

    private static bool SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaInnhold_TidligereAdresse(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int nextOffset,
        object? value
    )
    {
        if (model.TidligereAdresse is null)
        {
            try
            {
                model.TidligereAdresse = new global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>();
            }
            catch
            {
                return false;
            }
        }
        return SetRecursive(model.TidligereAdresse, path, literalIndex, nextOffset, value);
    }

    private static bool SetRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        object? value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        var segment = ParseSegment(path, offset, out int nextOffset, out int literalIndex);
        return segment switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => TrySetValue<global::System.Guid>(val => model.AltinnRowId = val, value),
            "gate" when nextOffset is -1 && literalIndex is -1 => TrySetValue<string>(val => model.Gate = val, value),
            "postnummer" when nextOffset is -1 && literalIndex is -1 => TrySetValue<int?>(val => model.Postnummer = val, value),
            "poststed" when nextOffset is -1 && literalIndex is -1 => TrySetValue<string>(val => model.Poststed = val, value),
            "tags" => SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_Adresse_Tags(model, path, literalIndex, nextOffset, value),
            _ => false,
        };
    }

    private static bool SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Integration_Tests_Models_Adresse_Tags(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int nextOffset,
        object? value
    )
    {
        if (model.Tags is null)
        {
            try
            {
                model.Tags = new global::System.Collections.Generic.List<string>();
            }
            catch
            {
                return false;
            }
        }
        return SetRecursive(model.Tags, path, literalIndex, nextOffset, value);
    }

    private static bool SetRecursive(
        global::System.Collections.Generic.List<string>? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset,
        object? value
    )
    {
        if (model is null || literalIndex < 0)
        {
            return false;
        }

        // Create list elements if index is out of bounds
        while (model.Count <= literalIndex)
        {
            try
            {
                model.Add(global::System.Activator.CreateInstance<string>());
            }
            catch
            {
                return false;
            }
        }

        if (offset == -1)
                        {
                            return TrySetValue<string>(val => model[literalIndex] = val, value);
                        }
                        return false;

    }

    private static bool SetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset,
        object? value
    )
    {
        if (model is null || literalIndex < 0)
        {
            return false;
        }

        // Create list elements if index is out of bounds
        while (model.Count <= literalIndex)
        {
            try
            {
                model.Add(global::System.Activator.CreateInstance<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>());
            }
            catch
            {
                return false;
            }
        }

        return SetRecursive(model[literalIndex], path, offset, value);
    }

    #endregion Setters
    #region AddIndexToPath

    /// <inheritdoc />
    public global::System.ReadOnlySpan<char> AddIndexToPath(global::System.ReadOnlySpan<char> path, global::System.ReadOnlySpan<int> rowIndexes, global::System.Span<char> buffer)
    {
        if(path.IsEmpty)
        {
            return global::System.ReadOnlySpan<char>.Empty;
        }

        var bufferOffset = 0;
        var pathOffset = 0;

        AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_Skjema(
            path,
            pathOffset,
            rowIndexes,
            buffer,
            ref bufferOffset
        );

        return buffer[..bufferOffset];
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_Skjema(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "skjemanummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 12;
                return;
            case "skjemaversjon":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 13;
                return;
            case "skjemainnhold":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 13;

                if (literalIndex != -1)
                {
                    // Copy index from path to buffer
                    buffer[bufferOffset++] = '[';
                    if (!literalIndex.TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException($"Buffer too small to write index for {path}.");
                    }

                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    if (!rowIndexes[0].TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException($"Buffer too small to write index for {path}.");
                    }
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else if (pathOffset == -1)
                {
                    // No more segments in the path, and the last part is valid in a list
                    // without index (e.g. "model.listProperty" is valid, but "model.listProperty.val" needs an index)
                    return;
                }
                else
                {
                    // No index to write, but there are more segments in the path
                    // thus the path is not valid
                    bufferOffset = 0;
                    return;
                }
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaInnhold(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "eierAdresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaInnhold(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                return;
            case "navn":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                return;
            case "alder":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 5;
                return;
            case "deltar":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 6;
                return;
            case "adresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 7;
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "tidligere-adresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 17;

                if (literalIndex != -1)
                {
                    // Copy index from path to buffer
                    buffer[bufferOffset++] = '[';
                    if (!literalIndex.TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException($"Buffer too small to write index for {path}.");
                    }

                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    if (!rowIndexes[0].TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException($"Buffer too small to write index for {path}.");
                    }
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else if (pathOffset == -1)
                {
                    // No more segments in the path, and the last part is valid in a list
                    // without index (e.g. "model.listProperty" is valid, but "model.listProperty.val" needs an index)
                    return;
                }
                else
                {
                    // No index to write, but there are more segments in the path
                    // thus the path is not valid
                    bufferOffset = 0;
                    return;
                }
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Integration_Tests_Models_Adresse(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                return;
            case "gate":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                return;
            case "postnummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 10;
                return;
            case "poststed":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 8;
                return;
            case "tags":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;

                if (literalIndex != -1)
                {
                    // Copy index from path to buffer
                    buffer[bufferOffset++] = '[';
                    if (!literalIndex.TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException($"Buffer too small to write index for {path}.");
                    }

                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    if (!rowIndexes[0].TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException($"Buffer too small to write index for {path}.");
                    }
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else if (pathOffset == -1)
                {
                    // No more segments in the path, and the last part is valid in a list
                    // without index (e.g. "model.listProperty" is valid, but "model.listProperty.val" needs an index)
                    return;
                }
                else
                {
                    // No index to write, but there are more segments in the path
                    // thus the path is not valid
                    bufferOffset = 0;
                    return;
                }
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    #endregion AddIndexToPath
    #region Copy

    /// <inheritdoc />
    public global::Altinn.App.Core.Internal.Data.IFormDataWrapper Copy()
    {
        return new Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaFormDataWrapper(CopyRecursive(_dataModel));
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema? CopyRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            Skjemanummer = data.Skjemanummer,
            Skjemaversjon = data.Skjemaversjon,
            Skjemainnhold = CopyRecursive(data.Skjemainnhold),
            EierAdresse = CopyRecursive(data.EierAdresse),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("list")]
    private static global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>? CopyRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>? list
    )
    {
        if (list is null)
        {
            return null;
        }

        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?> result = new(list.Count);
        foreach (var item in list)
        {
            result.Add(CopyRecursive(item));
        }

        return result;
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold? CopyRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            AltinnRowId = data.AltinnRowId,
            Navn = data.Navn,
            Alder = data.Alder,
            Deltar = data.Deltar,
            Adresse = CopyRecursive(data.Adresse),
            TidligereAdresse = CopyRecursive(data.TidligereAdresse),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse? CopyRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            AltinnRowId = data.AltinnRowId,
            Gate = data.Gate,
            Postnummer = data.Postnummer,
            Poststed = data.Poststed,
            Tags = CopyRecursive(data.Tags),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("list")]
    private static global::System.Collections.Generic.List<string>? CopyRecursive(
        global::System.Collections.Generic.List<string>? list
    )
    {
        if (list is null)
        {
            return null;
        }

        global::System.Collections.Generic.List<string> result = new(list.Count);
        foreach (var item in list)
        {
            result.Add(item);
        }

        return result;
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("list")]
    private static global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>? CopyRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>? list
    )
    {
        if (list is null)
        {
            return null;
        }

        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse> result = new(list.Count);
        foreach (var item in list)
        {
            result.Add(CopyRecursive(item));
        }

        return result;
    }

    #endregion Copy
    #region Remove

    /// <inheritdoc />
    public void RemoveField(global::System.ReadOnlySpan<char> path, global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption)
    {
        if (path.IsEmpty)
        {
            return;
        }

        RemoveRecursive(_dataModel, path, 0, rowRemovalOption);
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "skjemanummer" when (nextOffset is -1) && (literalIndex is -1):
                model.Skjemanummer = default;
                break;
            case "skjemaversjon" when (nextOffset is -1) && (literalIndex is -1):
                model.Skjemaversjon = default;
                break;
            case "skjemainnhold" when (nextOffset is -1) && (literalIndex is -1):
                model.Skjemainnhold = default;
                break;
            case "skjemainnhold":
                RemoveRecursive(model.Skjemainnhold, path, nextOffset, literalIndex, rowRemovalOption);
                break;
            case "eierAdresse" when (nextOffset is -1) && (literalIndex is -1):
                model.EierAdresse = default;
                break;
            case "eierAdresse":
                RemoveRecursive(model.EierAdresse, path, nextOffset, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        int index,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        if (index < 0 || index >= model.Count)
        {
            return;
        }
        if (offset == -1)
        {
            switch (rowRemovalOption)
            {
                case global::Altinn.App.Core.Helpers.RowRemovalOption.DeleteRow:
                    model.RemoveAt(index);
                    break;
                case global::Altinn.App.Core.Helpers.RowRemovalOption.SetToNull:
                    model[index] = default!;
                    break;
            }
        }
        else
        {
            RemoveRecursive(model[index], path, offset, rowRemovalOption);
        }
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "navn" when (nextOffset is -1) && (literalIndex is -1):
                model.Navn = default;
                break;
            case "alder" when (nextOffset is -1) && (literalIndex is -1):
                model.Alder = default;
                break;
            case "deltar" when (nextOffset is -1) && (literalIndex is -1):
                model.Deltar = default;
                break;
            case "adresse" when (nextOffset is -1) && (literalIndex is -1):
                model.Adresse = default;
                break;
            case "adresse":
                RemoveRecursive(model.Adresse, path, nextOffset, rowRemovalOption);
                break;
            case "tidligere-adresse" when (nextOffset is -1) && (literalIndex is -1):
                model.TidligereAdresse = default;
                break;
            case "tidligere-adresse":
                RemoveRecursive(model.TidligereAdresse, path, nextOffset, literalIndex, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "gate" when (nextOffset is -1) && (literalIndex is -1):
                model.Gate = default;
                break;
            case "postnummer" when (nextOffset is -1) && (literalIndex is -1):
                model.Postnummer = default;
                break;
            case "poststed" when (nextOffset is -1) && (literalIndex is -1):
                model.Poststed = default;
                break;
            case "tags" when (nextOffset is -1) && (literalIndex is -1):
                model.Tags = default;
                break;
            case "tags":
                RemoveRecursive(model.Tags, path, nextOffset, literalIndex, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<string>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        int index,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        if (index < 0 || index >= model.Count)
        {
            return;
        }
        if (offset == -1)
        {
            switch (rowRemovalOption)
            {
                case global::Altinn.App.Core.Helpers.RowRemovalOption.DeleteRow:
                    model.RemoveAt(index);
                    break;
                case global::Altinn.App.Core.Helpers.RowRemovalOption.SetToNull:
                    model[index] = default!;
                    break;
            }
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        int index,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        if (index < 0 || index >= model.Count)
        {
            return;
        }
        if (offset == -1)
        {
            switch (rowRemovalOption)
            {
                case global::Altinn.App.Core.Helpers.RowRemovalOption.DeleteRow:
                    model.RemoveAt(index);
                    break;
                case global::Altinn.App.Core.Helpers.RowRemovalOption.SetToNull:
                    model[index] = default!;
                    break;
            }
        }
        else
        {
            RemoveRecursive(model[index], path, offset, rowRemovalOption);
        }
    }

    #endregion Remove
    #region AltinnRowIds

    /// <inheritdoc />
    public void RemoveAltinnRowIds()
    {
        SetAltinnRowIds(_dataModel, initialize: false);
    }

    /// <inheritdoc />
    public void InitializeAltinnRowIds()
    {
        SetAltinnRowIds(_dataModel, initialize: true);
    }

    private static void SetAltinnRowIds(global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema dataModel, bool initialize)
    {
        if(dataModel.Skjemainnhold is not null)
        {
            foreach (var item in dataModel.Skjemainnhold)
            {
                if (item is not null)
                {
                    SetAltinnRowIds(item, initialize);
                }
            }
        }
        if(dataModel.EierAdresse is not null)
        {
            SetAltinnRowIds(dataModel.EierAdresse, initialize);
        }
    }

    private static void SetAltinnRowIds(global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold dataModel, bool initialize)
    {
        if (!initialize)
        {
            dataModel.AltinnRowId = global::System.Guid.Empty;
        }
        else if (dataModel.AltinnRowId == global::System.Guid.Empty)
        {
            dataModel.AltinnRowId = global::System.Guid.NewGuid();
        }
        if(dataModel.Adresse is not null)
        {
            SetAltinnRowIds(dataModel.Adresse, initialize);
        }
        if(dataModel.TidligereAdresse is not null)
        {
            foreach (var item in dataModel.TidligereAdresse)
            {
                if (item is not null)
                {
                    SetAltinnRowIds(item, initialize);
                }
            }
        }
    }

    private static void SetAltinnRowIds(global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse dataModel, bool initialize)
    {
        if (!initialize)
        {
            dataModel.AltinnRowId = global::System.Guid.Empty;
        }
        else if (dataModel.AltinnRowId == global::System.Guid.Empty)
        {
            dataModel.AltinnRowId = global::System.Guid.NewGuid();
        }
    }

    #endregion AltinnRowIds
    private static bool TrySetValue<T>(global::System.Action<T> setter, object? value)
    {
        if (value is null)
        {
            if (typeof(T).IsValueType && global::System.Nullable.GetUnderlyingType(typeof(T)) is null)
            {
                return false;
            }
            setter(default(T)!);
            return true;
        }

        if (value is T typedValue)
        {
            setter(typedValue);
            return true;
        }

        try
        {
            var targetType = typeof(T);
            var underlyingType = global::System.Nullable.GetUnderlyingType(targetType);
            if (underlyingType is not null)
            {
                targetType = underlyingType;
            }

            if (targetType == typeof(string))
            {
                setter((T)(object)value.ToString()!);
                return true;
            }

            if (targetType == typeof(int))
            {
                setter((T)(object)global::System.Convert.ToInt32(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType == typeof(long))
            {
                setter((T)(object)global::System.Convert.ToInt64(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType == typeof(decimal))
            {
                setter((T)(object)global::System.Convert.ToDecimal(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType == typeof(double))
            {
                setter((T)(object)global::System.Convert.ToDouble(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType == typeof(float))
            {
                setter((T)(object)global::System.Convert.ToSingle(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType == typeof(bool))
            {
                setter((T)(object)global::System.Convert.ToBoolean(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType == typeof(global::System.DateTime))
            {
                setter((T)(object)global::System.Convert.ToDateTime(value, global::System.Globalization.CultureInfo.InvariantCulture));
                return true;
            }

            if (targetType.IsEnum)
            {
                setter((T)global::System.Enum.Parse(targetType, value.ToString() ?? string.Empty));
                return true;
            }

            setter((T)global::System.Convert.ChangeType(value, targetType, global::System.Globalization.CultureInfo.InvariantCulture));
            return true;
        }
        catch
        {
            return false;
        }
    }

    public static global::System.ReadOnlySpan<char> ParseSegment(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset, out int literalIndex)
    {
        if (offset < 0 || offset > path.Length)
        {
            throw new global::System.ArgumentOutOfRangeException(nameof(offset));
        }

        for (int i = offset; i < path.Length; i++)
        {
            switch (path[i])
            {
                case '.':
                    nextOffset = i + 1;
                    literalIndex = -1;
                    return path[offset..i];
                case '[':
                    literalIndex = GetIndex(path, i + 1, out nextOffset);
                    return path[offset..i];
            }
        }

        // No markers found. Just return the rest of the path.
        nextOffset = -1;
        literalIndex = -1;
        return path[offset..];
    }

    private static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
    {
        var segment = path[offset..];
        var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
        if (bracketOffset < 0)
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Missing closing bracket ']' in {path}.");
        }

        if (!int.TryParse(
            segment[..bracketOffset],
            global::System.Globalization.NumberStyles.None,
            global::System.Globalization.CultureInfo.InvariantCulture,
            out var index))
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid index in {path}.");
        }

        if (index < 0)
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid negative index in {path}.");
        }

        if (offset + bracketOffset + 1 == path.Length)
        {
            // End of path
            nextOffset = -1;
            return index;
        }

        if (path[offset + bracketOffset + 1] != '.')
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid character after closing bracket ']' in {path}. Expected '.' or end of path.");
        }

        nextOffset = offset + bracketOffset + 2;

        return index;
    }

    [global::System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Register()
    {
        global::Altinn.App.Core.Internal.Data.FormDataWrapperFactory.Register<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema>(dataModel => new Altinn_App_SourceGenerator_Integration_Tests_Models_SkjemaFormDataWrapper(dataModel));
    }
}

// --------------------------------------------------
// ModelPathNode as json (for debugging)
// --------------------------------------------------
//
// {
//   "JsonName": "",
//   "CSharpName": "",
//   "TypeName": "global::Altinn.App.SourceGenerator.Integration.Tests.Models.Skjema",
//   "IsJsonValueType": false,
//   "Properties": [
//     {
//       "JsonName": "skjemanummer",
//       "CSharpName": "Skjemanummer",
//       "TypeName": "string",
//       "IsJsonValueType": true,
//     },
//     {
//       "JsonName": "skjemaversjon",
//       "CSharpName": "Skjemaversjon",
//       "TypeName": "string",
//       "IsJsonValueType": true,
//     },
//     {
//       "JsonName": "skjemainnhold",
//       "CSharpName": "Skjemainnhold",
//       "TypeName": "global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold",
//       "IsJsonValueType": false,
//       "ListType": "global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.SkjemaInnhold?>",
//       "Properties": [
//         {
//           "JsonName": "altinnRowId",
//           "CSharpName": "AltinnRowId",
//           "TypeName": "global::System.Guid",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "navn",
//           "CSharpName": "Navn",
//           "TypeName": "string",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "alder",
//           "CSharpName": "Alder",
//           "TypeName": "int?",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "deltar",
//           "CSharpName": "Deltar",
//           "TypeName": "bool?",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "adresse",
//           "CSharpName": "Adresse",
//           "TypeName": "global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse",
//           "IsJsonValueType": false,
//           "Properties": [
//             {
//               "JsonName": "altinnRowId",
//               "CSharpName": "AltinnRowId",
//               "TypeName": "global::System.Guid",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "gate",
//               "CSharpName": "Gate",
//               "TypeName": "string",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "postnummer",
//               "CSharpName": "Postnummer",
//               "TypeName": "int?",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "poststed",
//               "CSharpName": "Poststed",
//               "TypeName": "string",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "tags",
//               "CSharpName": "Tags",
//               "TypeName": "string",
//               "IsJsonValueType": true,
//               "ListType": "global::System.Collections.Generic.List<string>",
//             }
//           ]
//         },
//         {
//           "JsonName": "tidligere-adresse",
//           "CSharpName": "TidligereAdresse",
//           "TypeName": "global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse",
//           "IsJsonValueType": false,
//           "ListType": "global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse>",
//           "Properties": [
//             {
//               "JsonName": "altinnRowId",
//               "CSharpName": "AltinnRowId",
//               "TypeName": "global::System.Guid",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "gate",
//               "CSharpName": "Gate",
//               "TypeName": "string",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "postnummer",
//               "CSharpName": "Postnummer",
//               "TypeName": "int?",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "poststed",
//               "CSharpName": "Poststed",
//               "TypeName": "string",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "tags",
//               "CSharpName": "Tags",
//               "TypeName": "string",
//               "IsJsonValueType": true,
//               "ListType": "global::System.Collections.Generic.List<string>",
//             }
//           ]
//         }
//       ]
//     },
//     {
//       "JsonName": "eierAdresse",
//       "CSharpName": "EierAdresse",
//       "TypeName": "global::Altinn.App.SourceGenerator.Integration.Tests.Models.Adresse",
//       "IsJsonValueType": false,
//       "Properties": [
//         {
//           "JsonName": "altinnRowId",
//           "CSharpName": "AltinnRowId",
//           "TypeName": "global::System.Guid",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "gate",
//           "CSharpName": "Gate",
//           "TypeName": "string",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "postnummer",
//           "CSharpName": "Postnummer",
//           "TypeName": "int?",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "poststed",
//           "CSharpName": "Poststed",
//           "TypeName": "string",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "tags",
//           "CSharpName": "Tags",
//           "TypeName": "string",
//           "IsJsonValueType": true,
//           "ListType": "global::System.Collections.Generic.List<string>",
//         }
//       ]
//     }
//   ]
// }
