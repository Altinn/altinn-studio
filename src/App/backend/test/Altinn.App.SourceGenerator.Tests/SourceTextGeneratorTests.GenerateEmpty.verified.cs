// <auto-generated/>
#nullable enable

[global::System.CodeDom.Compiler.GeneratedCode("Altinn.App.Analyzers", "1.0.0.0")]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public sealed class Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper
    : global::Altinn.App.Core.Internal.Data.IFormDataWrapper
{
    private readonly global::Altinn.App.SourceGenerator.Tests.Empty _dataModel;

    public global::System.Type BackingDataType => typeof(global::Altinn.App.SourceGenerator.Tests.Empty);

    public T BackingData<T>()
        where T : class
    {
        return _dataModel as T
            ?? throw new global::System.InvalidCastException(
                $"Attempted to cast data model of type Altinn.App.SourceGenerator.Tests.Empty to {typeof(T).FullName}"
            );
    }

    public Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(object dataModel)
    {
        _dataModel =
            dataModel as global::Altinn.App.SourceGenerator.Tests.Empty
            ?? throw new global::System.ArgumentException(
                $"Data model must be of type Altinn.App.SourceGenerator.Tests.Empty, (was {dataModel?.GetType().FullName ?? "null"})"
            );
    }

    #region Getters

    /// <inheritdoc />
    public object? Get(global::System.ReadOnlySpan<char> path) => null;

    #endregion Getters
    #region AddIndexToPath

    /// <inheritdoc />
    public global::System.ReadOnlySpan<char> AddIndexToPath(global::System.ReadOnlySpan<char> path, global::System.ReadOnlySpan<int> rowIndexes, global::System.Span<char> buffer)
    {
        if(path.IsEmpty)
        {
            return global::System.ReadOnlySpan<char>.Empty;
        }

        var bufferOffset = 0;
        var pathOffset = 0;

        AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Empty(
            path,
            pathOffset,
            rowIndexes,
            buffer,
            ref bufferOffset
        );

        return buffer[..bufferOffset];
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Empty(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            default:
                bufferOffset = 0;
                return;
        }
    }

    #endregion AddIndexToPath
    #region Copy

    /// <inheritdoc />
    public global::Altinn.App.Core.Internal.Data.IFormDataWrapper Copy()
    {
        return new Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(CopyRecursive(_dataModel));
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Empty? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Empty? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new();
    }

    #endregion Copy
    #region Remove

    /// <inheritdoc />
    public void RemoveField(global::System.ReadOnlySpan<char> path, global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption) { }

    #endregion Remove
    #region AltinnRowIds

    /// <inheritdoc />
    public void RemoveAltinnRowIds() { }

    /// <inheritdoc />
    public void InitializeAltinnRowIds() { }

    #endregion AltinnRowIds
    public static global::System.ReadOnlySpan<char> ParseSegment(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset, out int literalIndex)
    {
        if (offset < 0 || offset >= path.Length)
        {
            throw new global::System.ArgumentOutOfRangeException(nameof(offset));
        }

        for (int i = offset; i < path.Length; i++)
        {
            switch (path[i])
            {
                case '.':
                    nextOffset = i + 1;
                    literalIndex = -1;
                    return path[offset..i];
                case '[':
                    literalIndex = GetIndex(path, i + 1, out nextOffset);
                    return path[offset..i];
            }
        }

        // No markers found. Just return the rest of the path.
        nextOffset = -1;
        literalIndex = -1;
        return path[offset..];
    }

    private static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
    {
        var segment = path[offset..];
        var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
        if (bracketOffset < 0)
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Missing closing bracket ']' in {path}.");
        }

        if (!int.TryParse(segment[..bracketOffset], out var index))
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid index in {path}.");
        }

        if (index < 0)
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid negative index in {path}.");
        }

        nextOffset = offset + bracketOffset + 2;
        if (nextOffset >= path.Length)
        {
            nextOffset = -1;
        }

        return index;
    }

    [global::System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Register()
    {
        global::Altinn.App.Core.Internal.Data.FormDataWrapperFactory.Register<global::Altinn.App.SourceGenerator.Tests.Empty>(dataModel => new Altinn_App_SourceGenerator_Tests_EmptyFormDataWrapper(dataModel));
    }
}

// --------------------------------------------------
// ModelPathNode as json (for debugging)
// --------------------------------------------------
//
// {
//   "JsonName": "",
//   "CSharpName": "",
//   "TypeName": "global::Altinn.App.SourceGenerator.Tests.Empty",
// }
