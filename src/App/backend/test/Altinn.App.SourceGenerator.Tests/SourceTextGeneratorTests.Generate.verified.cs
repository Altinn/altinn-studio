// <auto-generated/>
#nullable enable

[global::System.CodeDom.Compiler.GeneratedCode("Altinn.App.Analyzers", "1.0.0.0")]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public sealed class Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper
    : global::Altinn.App.Core.Internal.Data.IFormDataWrapper
{
    private readonly global::Altinn.App.SourceGenerator.Tests.Skjema _dataModel;

    public global::System.Type BackingDataType => typeof(global::Altinn.App.SourceGenerator.Tests.Skjema);

    public T BackingData<T>()
        where T : class
    {
        return _dataModel as T
            ?? throw new global::System.InvalidCastException(
                $"Attempted to cast data model of type Altinn.App.SourceGenerator.Tests.Skjema to {typeof(T).FullName}"
            );
    }

    public Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper(object dataModel)
    {
        _dataModel =
            dataModel as global::Altinn.App.SourceGenerator.Tests.Skjema
            ?? throw new global::System.ArgumentException(
                $"Data model must be of type Altinn.App.SourceGenerator.Tests.Skjema, (was {dataModel?.GetType().FullName ?? "null"})"
            );
    }

    #region Getters

    /// <inheritdoc />
    public object? Get(global::System.ReadOnlySpan<char> path)
    {
        if (path.IsEmpty)
        {
            return null;
        }

        return GetRecursive(_dataModel, path, 0);
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "skjemanummer" when nextOffset is -1 && literalIndex is -1 => model.Skjemanummer,
            "skjemaversjon" when nextOffset is -1 && literalIndex is -1 => model.Skjemaversjon,
            "skjemainnhold" => GetRecursive(model.Skjemainnhold, path, literalIndex, nextOffset),
            "eierAdresse" when literalIndex is -1 => GetRecursive(model.EierAdresse, path, nextOffset),
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset
    )
    {
        if (literalIndex == -1)
        {
            return model;
        }

        if (model is null || literalIndex < 0 || literalIndex >= model.Count)
        {
            return null;
        }

        return GetRecursive(model[literalIndex], path, offset);
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold>? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => model.AltinnRowId,
            "navn" when nextOffset is -1 && literalIndex is -1 => model.Navn,
            "alder" when nextOffset is -1 && literalIndex is -1 => model.Alder,
            "deltar" when nextOffset is -1 && literalIndex is -1 => model.Deltar,
            "adresse" when literalIndex is -1 => GetRecursive(model.Adresse, path, nextOffset),
            "tidligere-adresse" => GetRecursive(model.TidligereAdresse, path, literalIndex, nextOffset),
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => model.AltinnRowId,
            "gate" when nextOffset is -1 && literalIndex is -1 => model.Gate,
            "postnummer" when nextOffset is -1 && literalIndex is -1 => model.Postnummer,
            "poststed" when nextOffset is -1 && literalIndex is -1 => model.Poststed,
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    private static object? GetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int offset
    )
    {
        if (model is null || offset == -1)
        {
            return model;
        }

        return ParseSegment(path, offset, out int nextOffset, out int literalIndex) switch
        {
            "altinnRowId" when nextOffset is -1 && literalIndex is -1 => model.AltinnRowId,
            "gate" when nextOffset is -1 && literalIndex is -1 => model.Gate,
            "postnummer" when nextOffset is -1 && literalIndex is -1 => model.Postnummer,
            "poststed" when nextOffset is -1 && literalIndex is -1 => model.Poststed,
            // _ => throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"{path} is not a valid path."),
            _ => null,
        };
    }

    #endregion Getters
    #region Setters

    /// <inheritdoc />
    public bool Set(
        global::System.ReadOnlySpan<char> path,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        if (path.IsEmpty)
        {
            return false;
        }

        return SetRecursive(_dataModel, path, 0, value);
    }

    private static bool SetRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "skjemanummer" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Skjemanummer))
                {
                    model.Skjemanummer = result_Skjemanummer;
                    return true;
                }
                return false;
            case "skjemaversjon" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Skjemaversjon))
                {
                    model.Skjemaversjon = result_Skjemaversjon;
                    return true;
                }
                return false;
            case "skjemainnhold":
                return SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Tests_Skjema_Skjemainnhold(
                    model,
                    path,
                    literalIndex,
                    nextOffset,
                    value
                );
            case "eierAdresse" when literalIndex is -1:
                return SetRecursive_WithObjectCreation_Altinn_App_SourceGenerator_Tests_Skjema_EierAdresse(
                    model,
                    path,
                    nextOffset,
                    value
                );
            default:
                return false;
        }
    }

    private static bool SetRecursive_WithListCreation_Altinn_App_SourceGenerator_Tests_Skjema_Skjemainnhold(
        global::Altinn.App.SourceGenerator.Tests.Skjema model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int nextOffset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        model.Skjemainnhold ??= new();
        return SetRecursive(model.Skjemainnhold, path, literalIndex, nextOffset, value);
    }

    private static bool SetRecursive_WithObjectCreation_Altinn_App_SourceGenerator_Tests_Skjema_EierAdresse(
        global::Altinn.App.SourceGenerator.Tests.Skjema model,
        global::System.ReadOnlySpan<char> path,
        int nextOffset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        model.EierAdresse ??= new();
        return SetRecursive(model.EierAdresse, path, nextOffset, value);
    }

    private static bool SetRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int offset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        if (model is null || literalIndex < 0)
        {
            return false;
        }
        if (model.Count <= literalIndex)
        {
            return false;
        }
        return SetRecursive(model[literalIndex], path, offset, value);
    }

    private static bool SetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "altinnRowId" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Guid>(out var result_AltinnRowId))
                {
                    model.AltinnRowId = result_AltinnRowId;
                    return true;
                }
                return false;
            case "navn" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Navn))
                {
                    model.Navn = result_Navn;
                    return true;
                }
                return false;
            case "alder" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Int32?>(out var result_Alder))
                {
                    model.Alder = result_Alder;
                    return true;
                }
                return false;
            case "deltar" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Boolean?>(out var result_Deltar))
                {
                    model.Deltar = result_Deltar;
                    return true;
                }
                return false;
            case "adresse" when literalIndex is -1:
                return SetRecursive_WithObjectCreation_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_SkjemaInnhold__Adresse(
                    model,
                    path,
                    nextOffset,
                    value
                );
            case "tidligere-adresse":
                return SetRecursive_WithListCreation_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_SkjemaInnhold__TidligereAdresse(
                    model,
                    path,
                    literalIndex,
                    nextOffset,
                    value
                );
            default:
                return false;
        }
    }

    private static bool SetRecursive_WithObjectCreation_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_SkjemaInnhold__Adresse(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold> model,
        global::System.ReadOnlySpan<char> path,
        int nextOffset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        model.Adresse ??= new();
        return SetRecursive(model.Adresse, path, nextOffset, value);
    }

    private static bool SetRecursive_WithListCreation_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_SkjemaInnhold__TidligereAdresse(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold> model,
        global::System.ReadOnlySpan<char> path,
        int literalIndex,
        int nextOffset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        model.TidligereAdresse ??= new();
        return SetRecursive(model.TidligereAdresse, path, literalIndex, nextOffset, value);
    }

    private static bool SetRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "altinnRowId" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Guid>(out var result_AltinnRowId))
                {
                    model.AltinnRowId = result_AltinnRowId;
                    return true;
                }
                return false;
            case "gate" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Gate))
                {
                    model.Gate = result_Gate;
                    return true;
                }
                return false;
            case "postnummer" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Int32?>(out var result_Postnummer))
                {
                    model.Postnummer = result_Postnummer;
                    return true;
                }
                return false;
            case "poststed" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Poststed))
                {
                    model.Poststed = result_Poststed;
                    return true;
                }
                return false;
            default:
                return false;
        }
    }

    private static bool SetRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Internal.Expressions.ExpressionValue value
    )
    {
        if (model is null || offset == -1)
        {
            return false;
        }

        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "altinnRowId" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Guid>(out var result_AltinnRowId))
                {
                    model.AltinnRowId = result_AltinnRowId;
                    return true;
                }
                return false;
            case "gate" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Gate))
                {
                    model.Gate = result_Gate;
                    return true;
                }
                return false;
            case "postnummer" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.Int32?>(out var result_Postnummer))
                {
                    model.Postnummer = result_Postnummer;
                    return true;
                }
                return false;
            case "poststed" when nextOffset is -1 && literalIndex is -1:
                if (value.TryDeserialize<global::System.String?>(out var result_Poststed))
                {
                    model.Poststed = result_Poststed;
                    return true;
                }
                return false;
            default:
                return false;
        }
    }

    #endregion Setters
    #region AddIndexToPath

    /// <inheritdoc />
    public global::System.ReadOnlySpan<char> AddIndexToPath(
        global::System.ReadOnlySpan<char> path,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer
    )
    {
        if (path.IsEmpty)
        {
            return global::System.ReadOnlySpan<char>.Empty;
        }

        var bufferOffset = 0;
        var pathOffset = 0;

        AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Skjema(
            path,
            pathOffset,
            rowIndexes,
            buffer,
            ref bufferOffset
        );

        return buffer[..bufferOffset];
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Skjema(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "skjemanummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 12;
                return;
            case "skjemaversjon":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 13;
                return;
            case "skjemainnhold":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 13;

                if (literalIndex != -1)
                {
                    // Copy index from path to buffer
                    buffer[bufferOffset++] = '[';
                    if (!literalIndex.TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException(
                            $"Buffer too small to write index for {path}."
                        );
                    }

                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    if (!rowIndexes[0].TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException(
                            $"Buffer too small to write index for {path}."
                        );
                    }
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else if (pathOffset == -1)
                {
                    // No more segments in the path, and the last part is valid in a list
                    // without index (e.g. "model.listProperty" is valid, but "model.listProperty.val" needs an index)
                    return;
                }
                else
                {
                    // No index to write, but there are more segments in the path
                    // thus the path is not valid
                    bufferOffset = 0;
                    return;
                }
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_SkjemaInnhold_(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "eierAdresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_SkjemaInnhold_(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                return;
            case "navn":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                return;
            case "alder":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 5;
                return;
            case "deltar":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 6;
                return;
            case "adresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 7;
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            case "tidligere-adresse":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 17;

                if (literalIndex != -1)
                {
                    // Copy index from path to buffer
                    buffer[bufferOffset++] = '[';
                    if (!literalIndex.TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException(
                            $"Buffer too small to write index for {path}."
                        );
                    }

                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = default;
                }
                else if (rowIndexes.Length >= 1)
                {
                    // Write index from rowIndexes to buffer
                    buffer[bufferOffset++] = '[';
                    if (!rowIndexes[0].TryFormat(buffer[bufferOffset..], out int charsWritten))
                    {
                        throw new global::System.ArgumentException(
                            $"Buffer too small to write index for {path}."
                        );
                    }
                    bufferOffset += charsWritten;
                    buffer[bufferOffset++] = ']';
                    rowIndexes = rowIndexes.Slice(1);
                }
                else if (pathOffset == -1)
                {
                    // No more segments in the path, and the last part is valid in a list
                    // without index (e.g. "model.listProperty" is valid, but "model.listProperty.val" needs an index)
                    return;
                }
                else
                {
                    // No index to write, but there are more segments in the path
                    // thus the path is not valid
                    bufferOffset = 0;
                    return;
                }
                if (pathOffset != -1)
                {
                    AddIndexToPathRecursive_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_Adresse_(
                        path,
                        pathOffset,
                        rowIndexes,
                        buffer,
                        ref bufferOffset
                    );
                }
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_Altinn_App_SourceGenerator_Tests_Adresse(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                return;
            case "gate":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                return;
            case "postnummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 10;
                return;
            case "poststed":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 8;
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    private void AddIndexToPathRecursive_System_Collections_Generic_List_Altinn_App_SourceGenerator_Tests_Adresse_(
        global::System.ReadOnlySpan<char> path,
        int pathOffset,
        global::System.ReadOnlySpan<int> rowIndexes,
        global::System.Span<char> buffer,
        ref int bufferOffset
    )
    {
        if (bufferOffset > 0)
        {
            buffer[bufferOffset++] = '.';
        }
        var segment = ParseSegment(path, pathOffset, out pathOffset, out int literalIndex);
        switch (segment)
        {
            case "altinnRowId":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 11;
                return;
            case "gate":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 4;
                return;
            case "postnummer":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 10;
                return;
            case "poststed":
                segment.CopyTo(buffer.Slice(bufferOffset));
                bufferOffset += 8;
                return;
            default:
                bufferOffset = 0;
                return;
        }
    }

    #endregion AddIndexToPath
    #region Copy

    /// <inheritdoc />
    public global::Altinn.App.Core.Internal.Data.IFormDataWrapper Copy()
    {
        return new Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper(CopyRecursive(_dataModel));
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Skjema? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            // Initialize properties
            Skjemanummer = data.Skjemanummer,
            Skjemaversjon = data.Skjemaversjon,
            Skjemainnhold = CopyRecursive(data.Skjemainnhold),
            EierAdresse = CopyRecursive(data.EierAdresse),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("list")]
    private static global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? list
    )
    {
        if (list is null)
        {
            return null;
        }
        // csharpier-ignore
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold result = new (list.Count);

        foreach (var item in list)
        {
            result.Add(CopyRecursive(item));
        }

        return result;
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold>? CopyRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold>? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            // Initialize properties
            AltinnRowId = data.AltinnRowId,
            Navn = data.Navn,
            Alder = data.Alder,
            Deltar = data.Deltar,
            Adresse = CopyRecursive(data.Adresse),
            TidligereAdresse = CopyRecursive(data.TidligereAdresse),
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::Altinn.App.SourceGenerator.Tests.Adresse? CopyRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            // Initialize properties
            AltinnRowId = data.AltinnRowId,
            Gate = data.Gate,
            Postnummer = data.Postnummer,
            Poststed = data.Poststed,
        };
    }

    [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("data")]
    private static global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? CopyRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? data
    )
    {
        if (data is null)
        {
            return null;
        }

        return new()
        {
            // Initialize properties
            AltinnRowId = data.AltinnRowId,
            Gate = data.Gate,
            Postnummer = data.Postnummer,
            Poststed = data.Poststed,
        };
    }

    #endregion Copy
    #region Remove

    /// <inheritdoc />
    public void RemoveField(
        global::System.ReadOnlySpan<char> path,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (path.IsEmpty)
        {
            return;
        }

        RemoveRecursive(_dataModel, path, 0, rowRemovalOption);
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Tests.Skjema? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "skjemanummer" when (nextOffset is -1) && (literalIndex is -1):
                model.Skjemanummer = default;
                break;
            case "skjemaversjon" when (nextOffset is -1) && (literalIndex is -1):
                model.Skjemaversjon = default;
                break;
            case "skjemainnhold" when (nextOffset is -1) && (literalIndex is -1):
                model.Skjemainnhold = default;
                break;
            case "skjemainnhold":
                RemoveRecursive(model.Skjemainnhold, path, nextOffset, literalIndex, rowRemovalOption);
                break;
            case "eierAdresse" when (nextOffset is -1) && (literalIndex is -1):
                model.EierAdresse = default;
                break;
            case "eierAdresse":
                RemoveRecursive(model.EierAdresse, path, nextOffset, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        int index,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        if (index < 0 || index >= model.Count)
        {
            return;
        }
        if (offset == -1)
        {
            switch (rowRemovalOption)
            {
                case global::Altinn.App.Core.Helpers.RowRemovalOption.DeleteRow:
                    model.RemoveAt(index);
                    break;
                case global::Altinn.App.Core.Helpers.RowRemovalOption.SetToNull:
                    model[index] = default!;
                    break;
            }
        }
        else
        {
            RemoveRecursive(model[index], path, offset, rowRemovalOption);
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "navn" when (nextOffset is -1) && (literalIndex is -1):
                model.Navn = default;
                break;
            case "alder" when (nextOffset is -1) && (literalIndex is -1):
                model.Alder = default;
                break;
            case "deltar" when (nextOffset is -1) && (literalIndex is -1):
                model.Deltar = default;
                break;
            case "adresse" when (nextOffset is -1) && (literalIndex is -1):
                model.Adresse = default;
                break;
            case "adresse":
                RemoveRecursive(model.Adresse, path, nextOffset, rowRemovalOption);
                break;
            case "tidligere-adresse" when (nextOffset is -1) && (literalIndex is -1):
                model.TidligereAdresse = default;
                break;
            case "tidligere-adresse":
                RemoveRecursive(model.TidligereAdresse, path, nextOffset, literalIndex, rowRemovalOption);
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::Altinn.App.SourceGenerator.Tests.Adresse? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "gate" when (nextOffset is -1) && (literalIndex is -1):
                model.Gate = default;
                break;
            case "postnummer" when (nextOffset is -1) && (literalIndex is -1):
                model.Postnummer = default;
                break;
            case "poststed" when (nextOffset is -1) && (literalIndex is -1):
                model.Poststed = default;
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    private static void RemoveRecursive(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>? model,
        global::System.ReadOnlySpan<char> path,
        int offset,
        global::Altinn.App.Core.Helpers.RowRemovalOption rowRemovalOption
    )
    {
        if (model is null)
        {
            return;
        }
        switch (ParseSegment(path, offset, out int nextOffset, out int literalIndex))
        {
            case "gate" when (nextOffset is -1) && (literalIndex is -1):
                model.Gate = default;
                break;
            case "postnummer" when (nextOffset is -1) && (literalIndex is -1):
                model.Postnummer = default;
                break;
            case "poststed" when (nextOffset is -1) && (literalIndex is -1):
                model.Poststed = default;
                break;
            default:
                // throw new ArgumentException("{path} is not a valid path.");
                return;
        }
    }

    #endregion Remove
    #region AltinnRowIds

    /// <inheritdoc />
    public void RemoveAltinnRowIds()
    {
        SetAltinnRowIds(_dataModel, initialize: false);
    }

    /// <inheritdoc />
    public void InitializeAltinnRowIds()
    {
        SetAltinnRowIds(_dataModel, initialize: true);
    }

    private static void SetAltinnRowIds(
        global::Altinn.App.SourceGenerator.Tests.Skjema dataModel,
        bool initialize
    )
    {
        if (dataModel.Skjemainnhold is not null)
        {
            foreach (var item in dataModel.Skjemainnhold)
            {
                if (item is not null)
                {
                    SetAltinnRowIds(item, initialize);
                }
            }
        }
        if (dataModel.EierAdresse is not null)
        {
            SetAltinnRowIds(dataModel.EierAdresse, initialize);
        }
    }

    private static void SetAltinnRowIds(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold> dataModel,
        bool initialize
    )
    {
        if (!initialize)
        {
            dataModel.AltinnRowId = global::System.Guid.Empty;
        }
        else if (dataModel.AltinnRowId == global::System.Guid.Empty)
        {
            dataModel.AltinnRowId = global::System.Guid.NewGuid();
        }
        if (dataModel.Adresse is not null)
        {
            SetAltinnRowIds(dataModel.Adresse, initialize);
        }
        if (dataModel.TidligereAdresse is not null)
        {
            foreach (var item in dataModel.TidligereAdresse)
            {
                if (item is not null)
                {
                    SetAltinnRowIds(item, initialize);
                }
            }
        }
    }

    private static void SetAltinnRowIds(
        global::Altinn.App.SourceGenerator.Tests.Adresse dataModel,
        bool initialize
    )
    {
        if (!initialize)
        {
            dataModel.AltinnRowId = global::System.Guid.Empty;
        }
        else if (dataModel.AltinnRowId == global::System.Guid.Empty)
        {
            dataModel.AltinnRowId = global::System.Guid.NewGuid();
        }
    }

    private static void SetAltinnRowIds(
        global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse> dataModel,
        bool initialize
    )
    {
        if (!initialize)
        {
            dataModel.AltinnRowId = global::System.Guid.Empty;
        }
        else if (dataModel.AltinnRowId == global::System.Guid.Empty)
        {
            dataModel.AltinnRowId = global::System.Guid.NewGuid();
        }
    }

    #endregion AltinnRowIds
    public static global::System.ReadOnlySpan<char> ParseSegment(
        global::System.ReadOnlySpan<char> path,
        int offset,
        out int nextOffset,
        out int literalIndex
    )
    {
        if (offset < 0 || offset > path.Length)
        {
            throw new global::System.ArgumentOutOfRangeException(nameof(offset));
        }

        for (int i = offset; i < path.Length; i++)
        {
            switch (path[i])
            {
                case '.':
                    nextOffset = i + 1;
                    literalIndex = -1;
                    return path[offset..i];
                case '[':
                    literalIndex = GetIndex(path, i + 1, out nextOffset);
                    return path[offset..i];
            }
        }

        // No markers found. Just return the rest of the path.
        nextOffset = -1;
        literalIndex = -1;
        return path[offset..];
    }

    private static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
    {
        var segment = path[offset..];
        var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
        if (bracketOffset < 0)
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException(
                $"Missing closing bracket ']' in {path}."
            );
        }

        if (
            !int.TryParse(
                segment[..bracketOffset],
                global::System.Globalization.NumberStyles.None,
                global::System.Globalization.CultureInfo.InvariantCulture,
                out var index
            )
        )
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException(
                $"Invalid index in {path}."
            );
        }

        if (index < 0)
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException(
                $"Invalid negative index in {path}."
            );
        }

        if (offset + bracketOffset + 1 == path.Length)
        {
            // End of path
            nextOffset = -1;
            return index;
        }

        if (path[offset + bracketOffset + 1] != '.')
        {
            throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException(
                $"Invalid character after closing bracket ']' in {path}. Expected '.' or end of path."
            );
        }

        nextOffset = offset + bracketOffset + 2;

        return index;
    }

    [global::System.Runtime.CompilerServices.ModuleInitializer]
    internal static void Register()
    {
        global::Altinn.App.Core.Internal.Data.FormDataWrapperFactory.Register<global::Altinn.App.SourceGenerator.Tests.Skjema>(
            dataModel => new Altinn_App_SourceGenerator_Tests_SkjemaFormDataWrapper(dataModel)
        );
    }
}

// --------------------------------------------------
// ModelPathNode as json (for debugging)
// --------------------------------------------------
//
// {
//   "JsonName": "",
//   "CSharpName": "",
//   "IsNullable": false,
//   "TypeName": "global::Altinn.App.SourceGenerator.Tests.Skjema",
//   "IsJsonValueType": false,
//   "Properties": [
//     {
//       "JsonName": "skjemanummer",
//       "CSharpName": "Skjemanummer",
//       "IsNullable": true,
//       "TypeName": "global::System.String",
//       "IsJsonValueType": true,
//     },
//     {
//       "JsonName": "skjemaversjon",
//       "CSharpName": "Skjemaversjon",
//       "IsNullable": true,
//       "TypeName": "global::System.String",
//       "IsJsonValueType": true,
//     },
//     {
//       "JsonName": "skjemainnhold",
//       "CSharpName": "Skjemainnhold",
//       "IsNullable": true,
//       "TypeName": "global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold>",
//       "IsJsonValueType": false,
//       "ListType": "global::Altinn.App.SourceGenerator.Tests.SkjemaInnhold",
//       "Properties": [
//         {
//           "JsonName": "altinnRowId",
//           "CSharpName": "AltinnRowId",
//           "IsNullable": false,
//           "TypeName": "global::System.Guid",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "navn",
//           "CSharpName": "Navn",
//           "IsNullable": true,
//           "TypeName": "global::System.String",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "alder",
//           "CSharpName": "Alder",
//           "IsNullable": true,
//           "TypeName": "global::System.Int32",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "deltar",
//           "CSharpName": "Deltar",
//           "IsNullable": true,
//           "TypeName": "global::System.Boolean",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "adresse",
//           "CSharpName": "Adresse",
//           "IsNullable": true,
//           "TypeName": "global::Altinn.App.SourceGenerator.Tests.Adresse",
//           "IsJsonValueType": false,
//           "Properties": [
//             {
//               "JsonName": "altinnRowId",
//               "CSharpName": "AltinnRowId",
//               "IsNullable": false,
//               "TypeName": "global::System.Guid",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "gate",
//               "CSharpName": "Gate",
//               "IsNullable": true,
//               "TypeName": "global::System.String",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "postnummer",
//               "CSharpName": "Postnummer",
//               "IsNullable": true,
//               "TypeName": "global::System.Int32",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "poststed",
//               "CSharpName": "Poststed",
//               "IsNullable": true,
//               "TypeName": "global::System.String",
//               "IsJsonValueType": true,
//             }
//           ]
//         },
//         {
//           "JsonName": "tidligere-adresse",
//           "CSharpName": "TidligereAdresse",
//           "IsNullable": true,
//           "TypeName": "global::System.Collections.Generic.List<global::Altinn.App.SourceGenerator.Tests.Adresse>",
//           "IsJsonValueType": false,
//           "ListType": "global::Altinn.App.SourceGenerator.Tests.Adresse",
//           "Properties": [
//             {
//               "JsonName": "altinnRowId",
//               "CSharpName": "AltinnRowId",
//               "IsNullable": false,
//               "TypeName": "global::System.Guid",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "gate",
//               "CSharpName": "Gate",
//               "IsNullable": true,
//               "TypeName": "global::System.String",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "postnummer",
//               "CSharpName": "Postnummer",
//               "IsNullable": true,
//               "TypeName": "global::System.Int32",
//               "IsJsonValueType": true,
//             },
//             {
//               "JsonName": "poststed",
//               "CSharpName": "Poststed",
//               "IsNullable": true,
//               "TypeName": "global::System.String",
//               "IsJsonValueType": true,
//             }
//           ]
//         }
//       ]
//     },
//     {
//       "JsonName": "eierAdresse",
//       "CSharpName": "EierAdresse",
//       "IsNullable": true,
//       "TypeName": "global::Altinn.App.SourceGenerator.Tests.Adresse",
//       "IsJsonValueType": false,
//       "Properties": [
//         {
//           "JsonName": "altinnRowId",
//           "CSharpName": "AltinnRowId",
//           "IsNullable": false,
//           "TypeName": "global::System.Guid",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "gate",
//           "CSharpName": "Gate",
//           "IsNullable": true,
//           "TypeName": "global::System.String",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "postnummer",
//           "CSharpName": "Postnummer",
//           "IsNullable": true,
//           "TypeName": "global::System.Int32",
//           "IsJsonValueType": true,
//         },
//         {
//           "JsonName": "poststed",
//           "CSharpName": "Poststed",
//           "IsNullable": true,
//           "TypeName": "global::System.String",
//           "IsJsonValueType": true,
//         }
//       ]
//     }
//   ]
// }
