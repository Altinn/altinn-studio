using System.Text;

namespace Altinn.App.Analyzers.SourceTextGenerator;

/// <summary>
/// Generates source text for the IFormDataWrapper implementations.
/// </summary>
public static class SourceTextGenerator
{
    private static readonly string _sourceGeneratorVersion = "1.0.0.0";

    /// <summary>
    /// Generates the source text for the IFormDataWrapper implementation for the given root node.
    /// </summary>
    public static string GenerateSourceText(ModelPathNode rootNode)
    {
        var builder = new StringBuilder();
        builder.Append("// <auto-generated/>\r\n");
        var className = $"{rootNode.Name}FormDataWrapper";
        builder.Append(
            $$"""
            #nullable enable

            [global::System.CodeDom.Compiler.GeneratedCode("Altinn.App.Analyzers", "{{_sourceGeneratorVersion}}")]
            [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
            public sealed class {{className}}
                : global::Altinn.App.Core.Internal.Data.IFormDataWrapper
            {
                private readonly {{rootNode.TypeName}} _dataModel;

                public global::System.Type BackingDataType => typeof({{rootNode.TypeName}});

                public T BackingData<T>()
                    where T : class
                {
                    return _dataModel as T
                        ?? throw new global::System.InvalidCastException(
                            $"Attempted to cast data model of type {{rootNode.FullName}} to {typeof(T).FullName}"
                        );
                }

                public {{className}}(object dataModel)
                {
                    _dataModel =
                        dataModel as {{rootNode.TypeName}}
                        ?? throw new global::System.ArgumentException(
                            $"Data model must be of type {{rootNode.FullName}}, (was {dataModel?.GetType().FullName ?? "null"})"
                        );
                }

            """
        );
        builder.Append("\r\n    #region Getters\r\n");
        GetterGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion Getters\r\n");
        builder.Append("    #region AddIndexToPath\r\n");
        AddIndexToPathGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion AddIndexToPath\r\n");
        builder.Append("    #region Copy\r\n");
        CopyGenerator.Generate(builder, rootNode, className);
        builder.Append("\r\n    #endregion Copy\r\n");
        builder.Append("    #region Remove\r\n");
        RemoveGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion Remove\r\n");
        builder.Append("    #region AltinnRowIds\r\n");
        AltinnRowIdsGenerator.Generate(builder, rootNode);
        builder.Append("\r\n    #endregion AltinnRowIds\r\n");

        builder.Append(
            $$"""
                public static global::System.ReadOnlySpan<char> ParseSegment(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset, out int literalIndex)
                {
                    if (offset < 0 || offset > path.Length)
                    {
                        throw new global::System.ArgumentOutOfRangeException(nameof(offset));
                    }

                    for (int i = offset; i < path.Length; i++)
                    {
                        switch (path[i])
                        {
                            case '.':
                                nextOffset = i + 1;
                                literalIndex = -1;
                                return path[offset..i];
                            case '[':
                                literalIndex = GetIndex(path, i + 1, out nextOffset);
                                return path[offset..i];
                        }
                    }

                    // No markers found. Just return the rest of the path.
                    nextOffset = -1;
                    literalIndex = -1;
                    return path[offset..];
                }

                private static int GetIndex(global::System.ReadOnlySpan<char> path, int offset, out int nextOffset)
                {
                    var segment = path[offset..];
                    var bracketOffset = global::System.MemoryExtensions.IndexOf(segment, ']');
                    if (bracketOffset < 0)
                    {
                        throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Missing closing bracket ']' in {path}.");
                    }

                    if (!int.TryParse(
                        segment[..bracketOffset],
                        global::System.Globalization.NumberStyles.None,
                        global::System.Globalization.CultureInfo.InvariantCulture,
                        out var index))
                    {
                        throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid index in {path}.");
                    }

                    if (index < 0)
                    {
                        throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid negative index in {path}.");
                    }

                    if (offset + bracketOffset + 1 == path.Length)
                    {
                        // End of path
                        nextOffset = -1;
                        return index;
                    }

                    if (path[offset + bracketOffset + 1] != '.')
                    {
                        throw new global::Altinn.App.Core.Helpers.DataModel.DataModelException($"Invalid character after closing bracket ']' in {path}. Expected '.' or end of path.");
                    }

                    nextOffset = offset + bracketOffset + 2;

                    return index;
                }

                [global::System.Runtime.CompilerServices.ModuleInitializer]
                internal static void Register()
                {
                    global::Altinn.App.Core.Internal.Data.FormDataWrapperFactory.Register<{{rootNode.TypeName}}>(dataModel => new {{className}}(dataModel));
                }

            """
        );
        builder.Append("}\r\n");

        GenerateJsonComment.Generate(builder, rootNode);

        return builder.ToString();
    }
}
