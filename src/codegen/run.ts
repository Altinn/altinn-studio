import fs from 'node:fs/promises';
import path from 'node:path';

import { CodeGeneratorContext } from 'src/codegen/CodeGeneratorContext';
import { generateAllCommonTypes, generateCommonTypeScript } from 'src/codegen/Common';
import { LayoutSchemaV1 } from 'src/codegen/schemas/layout.schema.v1';
import { LayoutSetsSchemaV1 } from 'src/codegen/schemas/layout-sets.schema.v1';
import { LayoutSettingsSchemaV1 } from 'src/codegen/schemas/layoutSettings.schema.v1';
import { saveFile, saveTsFile } from 'src/codegen/tools';
import type { ComponentConfig } from 'src/codegen/ComponentConfig';
import type { SchemaFileProps } from 'src/codegen/SchemaFile';

async function getComponentList() {
  const out: { [folder: string]: string } = {};
  const files = await fs.readdir('src/layout');
  for (const file of files) {
    const stat = await fs.stat(path.join('src/layout', file));
    if (stat.isDirectory()) {
      out[file] = file;
    }
  }

  return out;
}

(async () => {
  const componentList = await getComponentList();
  const sortedKeys = Object.keys(componentList).sort((a, b) => a.localeCompare(b));
  const componentIndex = [
    '// This file is generated by running `yarn gen`',
    '',
    ...sortedKeys.map((key) => `import { Config as ${key}Config } from 'src/layout/${key}/config.generated';`),
    ...sortedKeys.map(
      (key) => `import type { TypeConfig as ${key}TypeConfig } from 'src/layout/${key}/config.generated';`,
    ),
    '',
    `export const ComponentConfigs = {`,
    ...sortedKeys.map((key) => `  ${componentList[key]}: ${key}Config,`),
    `};`,
    '',
    `export type ComponentTypeConfigs = {`,
    ...sortedKeys.map((key) => `  ${componentList[key]}: ${key}TypeConfig;`),
    `};`,
  ];

  const promises: Promise<void>[] = [];
  promises.push(saveFile('src/layout/components.generated.ts', componentIndex.join('\n')));

  // Make sure all common types has been generated first, so that they don't start extending
  // each other after being frozen
  generateAllCommonTypes();

  const configMap: { [key: string]: ComponentConfig } = {};
  for (const key of sortedKeys) {
    const tsPathConfig = `src/layout/${key}/config.generated.ts`;
    const tsPathDef = `src/layout/${key}/config.def.generated.ts`;

    const content = await CodeGeneratorContext.generateTypeScript(tsPathConfig, () => {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const config = require(`src/layout/${key}/config`).Config;
      config.setType(componentList[key], key);
      configMap[key] = config;
      return config.generateConfigFile();
    });
    const defClass = await CodeGeneratorContext.generateTypeScript(tsPathDef, () => configMap[key].generateDefClass());

    promises.push(saveTsFile(tsPathConfig, content));
    promises.push(saveTsFile(tsPathDef, defClass));
  }

  const schemaProps: SchemaFileProps = { configMap, componentList, sortedKeys };
  const schemas = [
    new LayoutSchemaV1(schemaProps),
    new LayoutSetsSchemaV1(schemaProps),
    new LayoutSettingsSchemaV1(schemaProps),
  ];

  const schemaPathBase = 'schemas/json/';
  for (const file of schemas) {
    const schemaPath = schemaPathBase + file.getFileName();
    const schema = await CodeGeneratorContext.generateJsonSchema(schemaPathBase, file);
    promises.push(saveFile(schemaPath, JSON.stringify(schema.result, null, 2)));
  }

  const commonTsPath = 'src/layout/common.generated.ts';
  promises.push(
    saveTsFile(
      commonTsPath,
      CodeGeneratorContext.generateTypeScript(commonTsPath, () => {
        generateCommonTypeScript();
        return ''; // Empty content, because all symbols are exported and registered in the context
      }),
    ),
  );

  await Promise.all(promises);
})();
