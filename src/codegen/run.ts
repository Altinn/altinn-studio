import fs from 'node:fs/promises';
import path from 'node:path';
import type { JSONSchema7 } from 'json-schema';

import { CodeGeneratorContext } from 'src/codegen/CodeGeneratorContext';
import { generateAllCommonTypes, generateCommonSchema, generateCommonTypeScript } from 'src/codegen/Common';
import { saveFile, saveTsFile } from 'src/codegen/tools';
import type { ComponentConfig } from 'src/codegen/ComponentConfig';

async function getComponentList() {
  const out: { [folder: string]: string } = {};
  const files = await fs.readdir('src/layout');
  for (const file of files) {
    const stat = await fs.stat(path.join('src/layout', file));
    if (stat.isDirectory()) {
      if (file === 'Address') {
        // Address is a special case, because we once named it 'AddressComponent', without any over the other components
        // having that suffix. We need to keep this for backwards compatibility, but our folder structure uses the name
        // without the suffix.
        out[file] = 'AddressComponent';
        continue;
      }

      out[file] = file;
    }
  }

  return out;
}

(async () => {
  const componentList = await getComponentList();
  const sortedKeys = Object.keys(componentList).sort((a, b) => a.localeCompare(b));
  const componentIndex = [
    '// This file is generated by running `yarn gen`',
    '',
    ...sortedKeys.map((key) => `import { Config as ${key}Config } from 'src/layout/${key}/config.generated';`),
    ...sortedKeys.map(
      (key) => `import type { TypeConfig as ${key}TypeConfig } from 'src/layout/${key}/config.generated';`,
    ),
    '',
    `export const ComponentConfigs = {`,
    ...sortedKeys.map((key) => `  ${componentList[key]}: ${key}Config,`),
    `};`,
    '',
    `export type ComponentTypeConfigs = {`,
    ...sortedKeys.map((key) => `  ${componentList[key]}: ${key}TypeConfig;`),
    `};`,
  ];

  const promises: Promise<void>[] = [];
  promises.push(saveFile('src/layout/components.generated.ts', componentIndex.join('\n')));

  // Make sure all common types has been generated first, so that they don't start extending
  // each other after being frozen
  generateAllCommonTypes();

  const configMap: { [key: string]: ComponentConfig } = {};
  for (const key of sortedKeys) {
    const tsPathConfig = `src/layout/${key}/config.generated.ts`;
    const tsPathDef = `src/layout/${key}/config.def.generated.ts`;

    const content = await CodeGeneratorContext.generateTypeScript(tsPathConfig, () => {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const config = require(`src/layout/${key}/config`).Config;
      config.setType(componentList[key], key);
      configMap[key] = config;
      return config.generateConfigFile();
    });
    const defClass = await CodeGeneratorContext.generateTypeScript(tsPathDef, () => configMap[key].generateDefClass());

    promises.push(saveTsFile(tsPathConfig, content));
    promises.push(saveTsFile(tsPathDef, defClass));
  }

  const schemaPath = 'schemas/json/layout/layout.schema.v1.json';
  const schema = await CodeGeneratorContext.generateJsonSchema(schemaPath, () => {
    generateCommonSchema();
    const base = generateFullSchema(sortedKeys, componentList);
    for (const key of sortedKeys) {
      const config = configMap[key];
      base.definitions = base.definitions || {};
      base.definitions[`Comp${key}`] = config.toJsonSchema();
    }

    return base;
  });
  promises.push(saveFile(schemaPath, JSON.stringify(schema.result, null, 2)));

  const commonTsPath = 'src/layout/common.generated.ts';
  promises.push(
    saveTsFile(
      commonTsPath,
      CodeGeneratorContext.generateTypeScript(commonTsPath, () => {
        generateCommonTypeScript();
        return ''; // Empty content, because all symbols are exported and registered in the context
      }),
    ),
  );

  await Promise.all(promises);
})();

function generateFullSchema(sortedKeys: string[], componentList: { [p: string]: string }): JSONSchema7 {
  return {
    $ref: '#/definitions/ILayoutFile',
    definitions: {
      AnyComponent: {
        type: 'object',
        properties: {
          type: {
            // This is a trick to make the type property required, but still override the type with a const value
            // in each of the component schemas (not normally possible with this code generator)
            title: 'Type',
            description: 'The component type',
            enum: sortedKeys.map((key) => componentList[key]),
          },
        },
        allOf: sortedKeys.map((key) => ({
          if: { properties: { type: { const: componentList[key] } } },
          then: { $ref: `#/definitions/Comp${key}` },
        })),
      },
    },
  };
}
