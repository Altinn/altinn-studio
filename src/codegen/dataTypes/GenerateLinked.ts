import type { JSONSchema7 } from 'json-schema';

import { Variant } from 'src/codegen/CG';
import { CodeGenerator } from 'src/codegen/CodeGenerator';

/**
 * Generates a type that is one of two types, depending on the current variant of code we're generating (i.e.
 * internal or external types). These variants could also be thought of as unresolved/resolved types, as all
 * expressions are resolved in the internal types and unresolved in the external types (meaning external configuration
 * can include expressions, but internal configuration have the evaluated results of these expressions).
 *
 * This is useful for 'children', for example, where the external type is a list of strings (component IDs), and the
 * internal type is a list of LayoutNode objects (as generated by the hierarchy generator).
 */
export class GenerateLinked<
  External extends CodeGenerator<any>,
  Internal extends CodeGenerator<any>,
> extends CodeGenerator<External> {
  public ext: External;
  public int: Internal;

  constructor(ext: External, int: Internal) {
    super();
    this.ext = ext;
    this.int = int;
  }

  transformTo(variant: Variant): this {
    this.currentVariant = variant;
    if (variant === Variant.Internal) {
      this.int = this.int.transformTo(variant) as Internal;
    } else {
      this.ext = this.ext.transformTo(variant) as External;
    }

    return this;
  }

  toTypeScript(): string {
    if (!this.currentVariant) {
      throw new Error('You need to transform this type to either external or internal before generating TypeScript');
    }

    return this.currentVariant === Variant.Internal ? this.int.toTypeScript() : this.ext.toTypeScript();
  }

  toJsonSchema(): JSONSchema7 {
    if (!this.currentVariant) {
      throw new Error('You need to transform this type to either external or internal before generating JsonSchema');
    }

    return this.currentVariant === Variant.Internal ? this.int.toJsonSchema() : this.ext.toJsonSchema();
  }

  containsVariationDifferences(): boolean {
    return true;
  }
}
