apiVersion: v1
kind: ConfigMap
metadata:
  name: testserver-content
  namespace: default
data:
  nginx.conf: |
    events {
        worker_connections 256;
    }
    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        server {
            listen 80;

            location /app/api/ {
                default_type application/json;
                return 200 '{"status":"ok","timestamp":"$time_iso8601","path":"$uri"}';
                add_header Content-Type application/json;
            }

            location /app/ {
                alias /usr/share/nginx/html/;
                index index.html;
            }
        }
    }
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>PDF Test Page</title>
        <link rel="stylesheet" type="text/css" href="https://altinncdn.no/toolkits/altinn-app-frontend/4.21.4/altinn-app-frontend.css">
        <style>
            h1 {
                color: #333;
            }
            .content {
                margin: 20px 0;
            }
            #readyForPrint {
                color: green;
                font-weight: bold;
                padding: 10px;
                border: 2px solid green;
                margin-top: 20px;
            }
        </style>
    </head>
    <body>
        <h1>Test PDF Generation</h1>
        <div class="content">
            <p>This is a test page for PDF generation integration tests.</p>
            <p>The page will simulate CPU work and IO operations before appending the "readyForPrint" element (target: ~1.5 seconds).</p>
        </div>

        <script>
            // Parse query parameters
            const urlParams = new URLSearchParams(window.location.search);
            const renderMode = urlParams.get('render') || 'heavy'; // 'light' or 'heavy'
            const logErrors = parseInt(urlParams.get('logerrors') || '0', 10);
            const throwErrors = parseInt(urlParams.get('throwerrors') || '0', 10);
            const neverReady = urlParams.has('neverready');

            // Start simulation when page fully loads
            window.onload = function() {
                // Log errors if requested
                for (let i = 0; i < logErrors; i++) {
                    console.error(`Test error ${i + 1} of ${logErrors}: Simulated error for testing`);
                }

                // Simulate CPU-intensive work and IO operations
                async function simulateLoading() {
                    const startTime = performance.now();

                    // Simulate CPU work: Heavy or light calculations
                    function cpuWork() {
                        const iterations = renderMode === 'light' ? 500000 : 5000000;
                        const domUpdateInterval = renderMode === 'light' ? 10000 : 1000;

                        let result = 0;
                        for (let i = 0; i < iterations; i++) {
                            result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);

                            if (i % domUpdateInterval === 0) {
                              const div = document.createElement('div');
                              div.textContent = `Item ${i}`;
                              div.id = `item-${i}`;
                              div.style = 'visibility: hidden;'
                              document.body.appendChild(div);
                            }
                        }
                        for (let i = 0; i < iterations; i++) {
                            result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);

                            if (i % domUpdateInterval === 0) {
                              const el = document.getElementById(`item-${i}`);
                              if (el) el.remove();
                            }
                        }
                        return result;
                    }

                    // Simulate IO: Fetch operations
                    async function ioWork() {
                        const fetchCount = renderMode === 'light' ? 2 : 5;
                        const promises = [];
                        for (let i = 0; i < fetchCount; i++) {
                            promises.push(
                                fetch(`api/data${i}`).catch(() => null)
                            );
                        }
                        await Promise.all(promises);
                    }

                    // Execute work in sequence
                    cpuWork();
                    ioWork().then(() => ioWork());
                    cpuWork();

                    // Calculate remaining time to reach target
                    const elapsed = performance.now() - startTime;
                    const targetTime = renderMode === 'light' ? 500 : 2000;
                    const remainingTime = Math.max(0, targetTime - elapsed);

                    // Wait for remaining time, then show ready state (unless neverready is set)
                    setTimeout(() => {
                        if (!neverReady) {
                            const readyDiv = document.createElement('div');
                            readyDiv.id = 'readyForPrint';
                            readyDiv.textContent = 'Ready for PDF generation!';
                            document.body.appendChild(readyDiv);
                        }

                        console.log(`Total loading time: ${performance.now() - startTime}ms`);
                        console.log(`Render mode: ${renderMode}, Never ready: ${neverReady}`);
                    }, remainingTime);
                }

                simulateLoading();

                // Throw errors if requested (wrapped in try-catch to continue execution)
                for (let i = 0; i < throwErrors; i++) {
                    if (i === throwErrors - 1) {
                        throw new Error(`Test thrown error ${i + 1} of ${throwErrors}: Simulated exception for testing`);
                    }
                    try {
                        throw new Error(`Test thrown error ${i + 1} of ${throwErrors}: Simulated exception for testing`);
                    } catch (e) {
                        console.error('Caught thrown error:', e);
                    }
                }
            };
        </script>
    </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: testserver
  namespace: default
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app: testserver
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testserver
spec:
  replicas: 1
  selector:
    matchLabels:
      app: testserver
  template:
    metadata:
      labels:
        app: testserver
    spec:
      containers:
      - name: nginx
        image: nginx:1.29-alpine
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        command: ["/bin/sh", "-c"]
        args:
          - |
            rm -f /etc/nginx/conf.d/default.conf
            nginx -g 'daemon off;'
        volumeMounts:
        - name: content
          mountPath: /usr/share/nginx/html
          readOnly: true
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
      volumes:
      - name: content
        configMap:
          name: testserver-content
      - name: nginx-config
        configMap:
          name: testserver-content
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: jumpbox-nginx-config
  namespace: default
data:
  nginx.conf: |
    events {
        worker_connections 256;
    }
    http {
        resolver kube-dns.kube-system.svc.cluster.local valid=10s;
        log_format proxy '$remote_addr - $remote_user [$time_local] "$request" '
                         '$status $body_bytes_sent "$http_referer" '
                         '"$http_user_agent" destination="$host" upstream="$upstream_addr"';
        server {
            listen 80;
            access_log /dev/stdout proxy;
            location / {
                proxy_pass http://$host;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            location /app {
                proxy_pass http://testserver.default.svc.cluster.local/app;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
    }
---
apiVersion: v1
kind: Service
metadata:
  name: jumpbox
  namespace: default
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app: jumpbox
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jumpbox
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: jumpbox
  template:
    metadata:
      labels:
        app: jumpbox
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          # Require pods to be on different hosts/nodes during scheduling
          # This prevents multiple replicas from running on the same node
          # improving fault tolerance if a node fails
          - topologyKey: kubernetes.io/hostname
            labelSelector:
              matchLabels:
                app: jumpbox
      containers:
      - name: nginx
        image: nginx:1.29-alpine
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
      volumes:
      - name: nginx-config
        configMap:
          name: jumpbox-nginx-config
---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: jumpbox
  namespace: default
spec:
  entryPoints:
    - traefik
  routes:
    - match: PathPrefix(`/`)
      kind: Rule
      services:
        - name: jumpbox
          port: 80
          scheme: http
