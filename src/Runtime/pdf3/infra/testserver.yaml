apiVersion: v1
kind: ConfigMap
metadata:
  name: testserver-content
  namespace: default
data:
  nginx.conf: |
    events {
        worker_connections 256;
    }
    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        server {
            listen 80;

            location /app/api/ {
                default_type application/json;
                return 200 '{"status":"ok","timestamp":"$time_iso8601","path":"$uri"}';
                add_header Content-Type application/json;
            }

            location /app/ {
                alias /usr/share/nginx/html/;
                index index.html;
            }
        }
    }
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>PDF Test Page</title>
        <link rel="stylesheet" type="text/css" href="https://altinncdn.no/toolkits/altinn-app-frontend/4/altinn-app-frontend.css">
        <style>
            h1 {
                color: #333;
            }
            .content {
                margin: 20px 0;
            }
            #readyForPrint {
                color: green;
                font-weight: bold;
                padding: 10px;
                border: 2px solid green;
                margin-top: 20px;
            }
        </style>
    </head>
    <body>
        <h1>Test PDF Generation</h1>
        <div class="content">
            <p>This is a test page for PDF generation integration tests.</p>
            <p>The page will simulate CPU work and IO operations before appending the "readyForPrint" element (target: ~1.5 seconds).</p>
        </div>

        <script>
            // Simulate CPU-intensive work and IO operations
            async function simulateLoading() {
                const startTime = performance.now();

                // Simulate CPU work: Heavy calculations
                function cpuWork() {
                    let result = 0;
                    for (let i = 0; i < 5000000; i++) {
                        result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);

                        if (i % 1000 === 0) {
                          const div = document.createElement('div');
                          div.textContent = `Item ${i}`;
                          div.id = `item-${i}`;
                          div.style = 'visibility: hidden;'
                          document.body.appendChild(div);
                        }
                    }
                    for (let i = 0; i < 5000000; i++) {
                        result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);

                        if (i % 1000 === 0) {
                          const el = document.getElementById(`item-${i}`);
                          el.remove();
                        }
                    }
                    return result;
                }

                // Simulate IO: Fetch operations
                async function ioWork() {
                    const promises = [];
                    for (let i = 0; i < 5; i++) {
                        promises.push(
                            fetch(`api/data${i}`).catch(() => null)
                        );
                    }
                    await Promise.all(promises);
                }

                // Execute work in sequence
                cpuWork();
                ioWork().then(() => ioWork());
                cpuWork();

                // Calculate remaining time to reach ~2 seconds
                const elapsed = performance.now() - startTime;
                const targetTime = 2000;
                const remainingTime = Math.max(0, targetTime - elapsed);

                // Wait for remaining time, then show ready state
                setTimeout(() => {
                    const readyDiv = document.createElement('div');
                    readyDiv.id = 'readyForPrint';
                    readyDiv.textContent = 'Ready for PDF generation!';
                    document.body.appendChild(readyDiv);

                    console.log(`Total loading time: ${performance.now() - startTime}ms`);
                }, remainingTime);
            }

            // Start simulation when page loads
            simulateLoading();
        </script>
    </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: testserver
  namespace: default
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app: testserver
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testserver
spec:
  replicas: 1
  selector:
    matchLabels:
      app: testserver
  template:
    metadata:
      labels:
        app: testserver
    spec:
      containers:
      - name: nginx
        image: nginx:1.29-alpine
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        command: ["/bin/sh", "-c"]
        args:
          - |
            rm -f /etc/nginx/conf.d/default.conf
            nginx -g 'daemon off;'
        volumeMounts:
        - name: content
          mountPath: /usr/share/nginx/html
          readOnly: true
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
      volumes:
      - name: content
        configMap:
          name: testserver-content
      - name: nginx-config
        configMap:
          name: testserver-content
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: jumpbox-nginx-config
  namespace: default
data:
  nginx.conf: |
    events {
        worker_connections 256;
    }
    http {
        resolver kube-dns.kube-system.svc.cluster.local valid=10s;
        log_format proxy '$remote_addr - $remote_user [$time_local] "$request" '
                         '$status $body_bytes_sent "$http_referer" '
                         '"$http_user_agent" destination="$host" upstream="$upstream_addr"';
        server {
            listen 80;
            access_log /dev/stdout proxy;
            location / {
                proxy_pass http://$host;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            location /app {
                proxy_pass http://testserver.default.svc.cluster.local/app;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
    }
---
apiVersion: v1
kind: Service
metadata:
  name: jumpbox
  namespace: default
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app: jumpbox
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jumpbox
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: jumpbox
  template:
    metadata:
      labels:
        app: jumpbox
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          # Require pods to be on different hosts/nodes during scheduling
          # This prevents multiple replicas from running on the same node
          # improving fault tolerance if a node fails
          - topologyKey: kubernetes.io/hostname
            labelSelector:
              matchLabels:
                app: jumpbox
      containers:
      - name: nginx
        image: nginx:1.29-alpine
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
      volumes:
      - name: nginx-config
        configMap:
          name: jumpbox-nginx-config
---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: jumpbox
  namespace: default
spec:
  entryPoints:
    - traefik
  routes:
    - match: PathPrefix(`/`)
      kind: Rule
      services:
        - name: jumpbox
          port: 80
          scheme: http
