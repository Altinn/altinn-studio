import React, { useState } from 'react';
import classes from './PolicyEditor.module.css';
import { ExpandablePolicyCard } from 'resourceadm/components/PolicyEditor/ExpandablePolicyCard';
import { CardButton } from 'resourceadm/components/PolicyEditor/CardButton';
import { Button, Heading, Alert } from '@digdir/design-system-react';
import {
  PolicyBackendType,
  PolicyRuleCardType,
  PolicyRuleBackendType,
  PolicySubjectType,
  RequiredAuthLevelType,
  PolicyActionType,
} from 'resourceadm/types/global';
import {
  mapPolicyRulesBackendObjectToPolicyRuleCardType,
  emptyPolicyRule,
  mapPolicyRuleToPolicyRuleBackendObject,
} from 'resourceadm/utils/policyEditorUtils';
import { VerificationModal } from 'resourceadm/components/PolicyEditor/VerificationModal';
import { SelectAuthLevel } from 'resourceadm/components/PolicyEditor/SelectAuthLevel';

interface Props {
  policy: PolicyBackendType;
  actions: PolicyActionType[];
  subjects: PolicySubjectType[];
  resourceType: string;
  resourceId: string;
  onSave: (policy: PolicyBackendType) => void;
  showAllErrors: boolean;
}
/**
 * Displays the content where a user can add and edit a policy
 *
 * @param props.policy the policy to edit
 * @param props.actions a list of actions that can be used in the rules
 * @param props.subjects a list of subjects that be can selected in the rules
 * @param props.resourceType the type of the resource so that it can fill the autogenerated field for the first resource
 * @param props.resourceId the ID of the resource so that it can fill the autogenerated field for the first resource
 * @param props.onSave function that saves the policy
 * @param props.showAllErrors flag to decide if errors should be shown or not
 */
export const PolicyEditor = ({
  policy,
  actions,
  subjects,
  resourceType,
  resourceId,
  onSave,
  showAllErrors,
}: Props) => {
  // TODO - translation

  const [policyRules, setPolicyRules] = useState<PolicyRuleCardType[]>(
    mapPolicyRulesBackendObjectToPolicyRuleCardType(subjects, actions, policy.rules)
  );
  const [requiredAuthLevel, setRequiredAuthLevel] = useState<RequiredAuthLevelType>(
    policy.requiredAuthenticationLevelEndUser
  );

  // Handle the new updated IDs of the rules when a rule is deleted / duplicated
  const [lastRuleId, setLastRuleId] = useState(policy.rules.length + 1);

  const [verificationModalOpen, setVerificationModalOpen] = useState(false);

  // To keep track of which rule to delete
  const [ruleIdToDelete, setRuleIdToDelete] = useState('0');

  /**
   * Displays all the rule cards
   */
  const displayRules = policyRules.map((pr, i) => {
    return (
      <div className={classes.space} key={i}>
        <ExpandablePolicyCard
          policyRule={pr}
          actions={actions}
          subjects={subjects}
          rules={policyRules}
          setPolicyRules={setPolicyRules}
          resourceId={resourceId}
          resourceType={resourceType}
          handleDuplicateRule={() => handleDuplicateRule(i)}
          handleDeleteRule={() => {
            setVerificationModalOpen(true);
            setRuleIdToDelete(pr.ruleId);
          }}
          showErrors={showAllErrors ? true : i !== policyRules.length - 1}
        />
      </div>
    );
  });

  /**
   * Returns the rule ID to be used on the new element, and
   * updates the store of the next rule id
   */
  const getRuleId = () => {
    const idTaken: boolean = policyRules.map((p) => p.ruleId).includes(lastRuleId.toString());

    const currentRuleId = idTaken ? lastRuleId + 1 : lastRuleId;
    setLastRuleId(currentRuleId + 1);
    return currentRuleId;
  };

  /**
   * Handles adding of more cards
   */
  const handleAddCardClick = () => {
    setPolicyRules((prevRules) => [
      ...prevRules,
      ...[
        {
          ...emptyPolicyRule,
          ruleId: getRuleId().toString(),
          resources: [[{ type: resourceType, id: resourceId }]],
        },
      ],
    ]);
  };

  /**
   * Duplicates a rule with all the content in it
   *
   * @param index the index of the rule to duplicate
   */
  const handleDuplicateRule = (index: number) => {
    const ruleToDuplicate: PolicyRuleCardType = {
      ...policyRules[index],
      ruleId: getRuleId().toString(),
    };

    // Create a deep copy of the object so the objects don't share same object reference
    const deepCopiedRuleToDuplicate: PolicyRuleCardType = JSON.parse(
      JSON.stringify(ruleToDuplicate)
    );

    setPolicyRules([...policyRules, deepCopiedRuleToDuplicate]);
  };

  /**
   * Deletes a rule from the list
   *
   * @param index the index of the rule to delete
   */
  const handleDeleteRule = (ruleId: string) => {
    const updatedRules = [...policyRules];
    const indexToRemove = updatedRules.findIndex((a) => a.ruleId === ruleId);
    updatedRules.splice(indexToRemove, 1);
    setPolicyRules(updatedRules);

    // Reset
    setVerificationModalOpen(false);
    setRuleIdToDelete('0');

    handleSavePolicy(updatedRules);
  };

  /**
   * Handle the saving of the updated policy
   */
  const handleSavePolicy = (rules: PolicyRuleCardType[]) => {
    const policyEditorRules: PolicyRuleBackendType[] = rules.map((pr) =>
      mapPolicyRuleToPolicyRuleBackendObject(subjects, actions, pr, resourceType, resourceId)
    );

    const updatedPolicy: PolicyBackendType = {
      rules: policyEditorRules,
      requiredAuthenticationLevelEndUser: requiredAuthLevel,
      requiredAuthenticationLevelOrg: '3',
    };
    onSave(updatedPolicy);
  };

  return (
    <div>
      <div className={classes.alertWrapper}>
        <Alert iconTitle='Du må ha minimum en regel for å publisere ressursen.' severity='info'>
          Du må ha minimum en regel for å publisere ressursen.
        </Alert>
      </div>
      <div className={classes.selectAuthLevelWrapper}>
        <div className={classes.selectAuthLevel}>
          <SelectAuthLevel
            value={requiredAuthLevel}
            setValue={(v) => setRequiredAuthLevel(v)}
            label='Velg påkrevd sikkerhetsnivå for bruker'
          />
        </div>
      </div>
      <Heading size='xsmall' spacing level={2} className={classes.subHeader}>
        Regler
      </Heading>
      {displayRules}
      <div className={classes.addCardButtonWrapper}>
        <CardButton buttonText='Legg til ekstra regelsett' onClick={handleAddCardClick} />
      </div>
      <Button type='button' onClick={() => handleSavePolicy(policyRules)}>
        Lagre tilgangsregler
      </Button>
      <VerificationModal
        isOpen={verificationModalOpen}
        onClose={() => setVerificationModalOpen(false)}
        text='Er du sikker på at du vil slette denne regelen?'
        closeButtonText='Nei, gå tilbake'
        actionButtonText='Ja, slett regel'
        onPerformAction={() => handleDeleteRule(ruleIdToDelete)}
      />
    </div>
  );
};
